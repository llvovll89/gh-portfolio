---
title: "프로그래밍 CS 총정리"
date: 2026-02-15
tags: [cs, programming, 알고리즘, 시스템]
---

# 프로그래밍 및 컴퓨터 과학 총정리 (2026-02-15)

이 문서는 프로그래밍과 컴퓨터 과학(Computer Science, CS)의 핵심 개념을 실무와 학습 관점에서 한 번에 훑을 수 있도록 요약합니다. 각 섹션은 핵심 아이디어, 대표 개념, 실무적 팁을 포함합니다.

## 목차

- 기초 수학 및 이론
- 자료구조
- 알고리즘 설계 기법
- 복잡도 이론
- 프로그래밍 언어와 패러다임
- 컴파일러와 런타임
- 운영체제(OS)
- 컴퓨터 구조 및 메모리
- 네트워킹 기초
- 데이터베이스
- 소프트웨어 공학 및 설계
- 테스트·배포·CI/CD
- 보안 기초
- 추천 학습 흐름과 참고자료

## 기초 수학 및 이론

- 이산수학: 집합, 관계, 그래프, 트리, 부울대수
  - 설명: 이산수학은 컴퓨터 과학의 수학적 토대입니다. 집합은 원소들의 모임을, 관계는 원소 간의 대응을, 그래프와 트리는 노드와 간선으로 모델링되는 구조를 제공합니다. 부울대수는 논리 연산(AND, OR, NOT)을 형식화합니다.
- 논리·증명: 직접증명, 모순증명, 수학적 귀납법
  - 설명: 정리의 타당성을 보이는 방법들로, 알고리즘의 정당성(정확성) 증명과 수학적 성질을 검증할 때 사용됩니다. 귀납법은 재귀적 알고리즘 증명에 특히 유용합니다.
- 그래프 이론: 정점/간선, 경로, 연결성, 사이클, 위상정렬
  - 설명: 그래프는 네트워크, 의존성, 경로 문제를 모델링합니다. 위상정렬은 DAG(사이클 없는 방향 그래프)에서 작업 순서를 결정할 때 사용합니다.
- 조합론·확률: 경우의 수, 기대값, 확률 분포(알고리즘 확률 분석에 중요)
  - 설명: 랜덤화 알고리즘, 평균/기댓값 분석, 확률적 경로 선택 등에서 필수적입니다.

### 예제

```text
문제: 동전 3번 던졌을 때 적어도 두 번 앞면이 나올 확률?
해설: 표본공간 크기 8, 앞면이 2번 또는 3번인 경우의 수는 3 + 1 = 4 → 확률 4/8 = 1/2
```

### 연습 문제

- 문제1: 그래프의 연결성(connected)에 대한 정의를 수식으로 작성하세요.
- 문제2: 수학적 귀납법을 사용해 1+2+...+n = n(n+1)/2 를 증명하세요.

### 정답 및 해설 (JS)

- 문제1 해답 (JS): 그래프를 인접리스트로 주었을 때 연결성 판별 함수

```js
// 그래프: { node: [neighbor,...], ... }
function isConnected(graph){
  const nodes = Object.keys(graph);
  if(nodes.length === 0) return true;
  const visited = new Set();
  const stack = [nodes[0]];
  while(stack.length){
    const v = stack.pop();
    if(visited.has(v)) continue;
    visited.add(v);
    for(const w of graph[v] || []) if(!visited.has(w)) stack.push(w);
  }
  return visited.size === nodes.length;
}

// 예시
// const g = { A:['B'], B:['A','C'], C:['B'] };
// console.log(isConnected(g)); // true
```

- 문제2 해설: 수학적 귀납법 증명 대신 JS로 n까지 합이 공식을 따르는지 검증

```js
function sumUpTo(n){
  return n*(n+1)/2;
}
function bruteSum(n){
  let s=0; for(let i=1;i<=n;i++) s+=i; return s;
}
for(let n=1;n<=20;n++){
  console.assert(sumUpTo(n)===bruteSum(n), `Mismatch at ${n}`);
}
console.log('검증 완료: 1..20');
```

간단한 JS 검증은 귀납법의 직관을 보조합니다. 수학적 증명은 기본귀납법 적용으로 정확합니다.

## 자료구조

- 배열(Array): 임의 접근 O(1), 삽입/삭제 비용
  - 설명: 메모리에 연속적으로 배치된 요소들의 집합입니다. 인덱스로 빠르게 접근 가능하지만 중간 삽입/삭제는 비용이 큽니다.
- 연결리스트(Linked List): 삽입/삭제 유리, 인덱스 접근 비효율
  - 설명: 각 노드가 다음(또는 이전) 노드 참조를 가지는 구조로 동적 삽입/삭제가 빠르지만 임의 접근은 느립니다.
- 스택/큐: LIFO/FIFO, DFS/BFS 구현에 사용
  - 설명: 스택은 후입선출(LIFO), 큐는 선입선출(FIFO) 규칙을 따릅니다. 스택은 재귀적 문제, 큐는 BFS나 작업 스케줄링에 사용됩니다.
- 해시 테이블(Hash): 평균 O(1) 조회, 충돌 해소(체이닝/오픈어드레싱)
  - 설명: 키를 해시 함수로 인덱스화하여 빠른 조회를 제공합니다. 충돌 처리 전략에 따라 성능과 메모리 특성이 달라집니다.
- 트리(Tree): 이진트리, 이진탐색트리(BST), AVL/Red-Black(균형 트리)
  - 설명: 계층적 데이터 모델입니다. BST는 정렬된 데이터의 빠른 탐색을 제공하고, AVL/Red-Black 같은 균형 트리는 최악의 경우에도 탐색 성능을 보장합니다.
- 힙(Heap): 우선순위 큐 구현, 힙 정렬
  - 설명: 완전이진트리 기반의 자료구조로 최댓값/최솟값을 빠르게 얻을 수 있어 우선순위 작업 스케줄링에 적합합니다.
- 그래프 표현: 인접행렬/인접리스트(희소/밀집에 따라 선택)
  - 설명: 인접행렬은 간선 존재 여부를 빠르게 체크하지만 메모리를 많이 쓰고, 인접리스트는 희소 그래프에 메모리 효율적입니다.

### 예제 (JavaScript)

```js
// 배열과 해시맵 사용 예
const arr = [1,2,3]; // O(1) 접근
const map = new Map(); // 해시맵
map.set('a', 1);
console.log(map.get('a'));
```

### 연습 문제

- 문제1: 단일 연결 리스트를 뒤집는 함수를 작성하세요(pseudocode 또는 원하는 언어).
- 문제2: 주어진 정수 배열에서 중복을 제거하는 해시 기반 알고리즘의 시간/공간 복잡도를 분석하세요.

### 정답 및 해설 (JS)

- 문제1 해답: 단일 연결 리스트 뒤집기 (JS)

```js
class Node { constructor(val, next=null){ this.val = val; this.next = next } }
function reverseList(head){
  let prev = null, cur = head;
  while(cur){
    const next = cur.next;
    cur.next = prev;
    prev = cur;
    cur = next;
  }
  return prev; // new head
}
// 사용: reverseList(head)
```

설명: 반복 방식으로 O(n) 시간, O(1) 추가 공간.

- 문제2 해답 및 복잡도 분석 (JS)

```js
function unique(arr){
  const seen = new Set();
  const out = [];
  for(const v of arr) if(!seen.has(v)){ seen.add(v); out.push(v); }
  return out;
}
```

설명: 시간 복잡도 O(n) 평균(해시 연산 O(1) 가정), 공간 복잡도 O(n) 추가(Set용).

## 알고리즘 설계 기법

- 정렬 알고리즘: 퀵, 머지, 힙, 계수정렬(특수 경우)
  - 설명: 퀵정렬은 평균적으로 빠르지만 최악의 경우 O(n^2), 머지정렬은 안정적이며 O(n log n) 보장, 계수정렬은 정수 키 범위가 작을 때 선형 시간 달성 가능.
- 탐색: 이진탐색(정렬 필요), 그래프 탐색(DFS/BFS)
  - 설명: 이진탐색은 정렬된 배열에서 O(log n) 탐색, DFS는 깊이 우선 탐색(스택/재귀 기반), BFS는 최단 경로(간선 가중치 1) 탐색에 유리합니다.
- 최소 신장트리: Kruskal, Prim
  - 설명: 연결된 가중치 그래프에서 모든 정점을 최소 비용으로 연결하는 트리를 만듭니다. Kruskal은 간선 정렬 기반, Prim은 정점 확장 기반입니다.
- 최단경로: Dijkstra, Bellman-Ford, Floyd-Warshall
  - 설명: Dijkstra는 음수 가중치가 없을 때서 효율적, Bellman-Ford는 음수 가중치 허용(음수 사이클 검출 가능), Floyd-Warshall은 모든 쌍 최단경로를 구합니다.
- 분할 정복(Divide & Conquer): 문제 분할 → 해결 → 병합
  - 설명: 하위 문제로 분할하여 해결한 뒤 결과를 합치는 방식으로 재귀적 문제에 강합니다(예: 머지정렬, 이진탐색).
- 동적 계획법(DP): 중복 하위문제와 최적 부분구조 활용
  - 설명: 하위 문제의 결과를 메모이제이션하거나 테이블화하여 중복 계산을 제거합니다(예: 피보나치, 배낭 문제).
- 탐욕 알고리즘(Greedy): 국소 최적 선택이 전체 최적을 보장할 때 사용
  - 설명: 각 단계에서 순간적으로 최적이라고 판단되는 선택을 반복합니다. 항상 옳은 것은 아니며 문제의 특성(교환 논리 등)을 검증해야 합니다.
- 백트래킹: 조합/순열 탐색(가지치기 중요)
  - 설명: 후보를 점진적으로 구성하며 조건을 만족하지 않으면 뒤로 되돌아가며 탐색(예: N-Queens, 부분집합 생성).

### 예제 (파이썬: 이진 검색)

```py
def binary_search(a, target):
  l, r = 0, len(a)-1
  while l <= r:
    m = (l + r) // 2
    if a[m] == target:
      return m
    elif a[m] < target:
      l = m + 1
    else:
      r = m - 1
  return -1
```

### 연습 문제

- 문제1: 동적 계획법(DP)으로 피보나치 수열을 O(n) 시간, O(1) 공간으로 구현하세요.
- 문제2: 탐욕 알고리즘이 항상 최적이 되는 예제와 그렇지 않은 예제를 하나씩 제시하고 이유를 설명하세요.

### 정답 및 해설 (JS)

- 문제1 해답: 피보나치 DP O(n) 시간, O(1) 공간

```js
function fib(n){
  if(n<=1) return n;
  let a=0,b=1;
  for(let i=2;i<=n;i++){
    const c = a + b;
    a = b; b = c;
  }
  return b;
}
```

- 문제2 해답: 탐욕 알고리즘 성공/실패 예제

```js
// 성공 예: 거스름돈(한국 화폐: 500,100,50,10) - 탐욕으로 최적 해
function coinChangeGreedy(amount, coins=[500,100,50,10]){
  const res = [];
  for(const c of coins){
    const k = Math.floor(amount / c);
    if(k>0) res.push([c,k]);
    amount %= c;
  }
  return res;
}

// 실패 예: 코인 집합 [4,3,1], 목표 6 => 탐욕(4+1+1 = 3 coins) vs 최적(3+3 = 2 coins)
function greedyFailExample(){
  const coins = [4,3,1];
  // greedy picks 4 then two 1s => 3 coins; optimal is two 3s => 2 coins
  return { coins, target: 6 };
}
```

설명: 탐욕 알고리즘은 탐욕 선택 속성이 성립할 때만 전체 최적을 보장합니다. 화폐 시스템이 '정당화되는' 경우(정규 통화 체계)엔 탐욕이 맞지만 임의 코인 집합에선 실패할 수 있습니다.

## 복잡도 이론

- 시간/공간 복잡도 표기법: Big-O, Θ, Ω
  - 설명: Big-O는 상한(최악)을 나타내며, Θ는 정확한 성장률, Ω는 하한(최선)을 나타냅니다. 알고리즘 비교의 표준 도구입니다.
- 시간 복잡도 주요 클래스: O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n), O(n!)
  - 설명: 각 클래스는 입력 크기 증가에 따른 실행 시간 증가율을 표현하며, 지수/팩토리얼은 실전에서 빠르게 불가능해집니다.
- NP, NP-완전성: 결정문제의 난이도 분류(예: SAT은 NP-완전)

### 예제

```text
입력 크기 n에 대해 O(n log n) 알고리즘은 n이 2배 될 때 대략 2 * log2(2n) / log2(n) 배의 시간이 걸립니다(성장률 참고).
```

### 연습 문제

- 문제1: O(n^2) 알고리즘이 n=10, n=1000일 때 상대적 시간 차이를 수치적으로 계산하세요.
- 문제2: NP 문제의 예시를 하나 제시하고, 왜 NP인지 설명하세요.

### 정답 및 해설 (JS)

- 문제1 해답: 단순 계산 스크립트

```js
function compareSquares(){
  const n1=10, n2=1000;
  const t1 = n1*n1; // 연산 수(상대적)
  const t2 = n2*n2;
  return { n1, t1, n2, t2, ratio: t2 / t1 };
}
console.log(compareSquares()); // {n1:10,t1:100,n2:1000,t2:1000000,ratio:10000}
```

- 문제2 해설: SAT(부울 만족 가능성 문제)

```text
예: (A OR B) AND (¬A OR C) ... 같은 부울식이 주어졌을 때, 전체 식을 참으로 만드는 변수 할당이 존재하는지 결정.
이유: 어떤 할당이 정답인지 다항 시간에 '검증'할 수 있으므로 NP에 속함. SAT는 NP-완전 문제의 대표 예.
```

## 프로그래밍 언어와 패러다임

- 절차적/명령형: 상태 변화 중심 (C 등)
  - 설명: 명령형 스타일은 프로그램 상태를 명시적으로 변경하며, 로우레벨 제어가 쉬워 시스템 프로그래밍에 적합합니다.
- 객체지향(OOP): 캡슐화, 상속, 다형성 (Java, C#)
  - 설명: 데이터와 동작을 객체로 묶어 모델링하며, 재사용성과 확장성을 향상시키는 설계 원칙을 제공합니다.
- 함수형 프로그래밍: 불변성, 고차함수, 순수함수 (Haskell, Elixir, 일부 JS/Scala 기능)
  - 설명: 상태 변경을 최소화하고 사이드 이펙트가 없는 함수를 중심으로 설계하여 병렬/동시성 문제를 완화합니다.
- 동시성·병렬성: 스레드, 코루틴, 이벤트 루프(비동기 I/O)
  - 설명: 동시성은 여러 작업의 논리적 동시 실행을, 병렬성은 물리적으로 동시에 실행을 의미합니다. 코루틴(경량 스레드)와 이벤트 루프는 고성능 I/O 처리를 돕습니다.

### 예제 (JavaScript vs Python 간단 비교)

```js
// JS: 비동기 이벤트 루프 사용 예
setTimeout(() => console.log('async'), 0);
console.log('sync');
```

```py
# Python: 동기적 예
print('sync')
```

### 연습 문제

- 문제1: 함수형 프로그래밍의 `map`과 `reduce` 예제를 작성하고, 각각의 장점을 설명하세요.
- 문제2: 코루틴(또는 async/await)이 스레드 기반 병렬성과 다른 점을 정리하세요.

### 정답 및 해설 (JS)

- 문제1 해답: `map`과 `reduce` 예제

```js
const nums = [1,2,3,4];
const doubled = nums.map(x => x*2); // [2,4,6,8]
const sum = nums.reduce((acc,x) => acc + x, 0); // 10
```

장점: `map`은 데이터 변환을, `reduce`는 누적/집계에 적합하며 사이드이펙트를 줄여 함수형 스타일로 테스트하기 쉬움.

- 문제2 해답: async/await(코루틴) vs 스레드

```js
// async example
async function fetchAll(urls){
  const promises = urls.map(u => fetch(u));
  return Promise.all(promises);
}
```

설명: 코루틴은 이벤트 루프 기반으로 많은 I/O 작업을 적은 메모리로 처리(경량). 스레드는 OS 스레드로 문맥교환 비용과 메모리 오버헤드가 큼. CPU 바운드 작업은 스레드/프로세스 병렬이 필요합니다.

## 컴파일러와 런타임

- 컴파일러 단계: 렉서 → 파서 → AST → 최적화 → 코드 생성
  - 설명: 렉서는 토큰화, 파서는 문법 분석으로 AST(추상 구문 트리)를 만들고, 최적화 단계에서 성능 향상을 적용한 뒤 기계어(또는 바이트코드)를 생성합니다.
- 인터프리터 vs AOT vs JIT: 실행 모델과 성능 특성
  - 설명: 인터프리터는 소스 코드를 한 줄씩 실행, AOT(사전 컴파일)는 실행 전에 전체를 컴파일, JIT는 런타임에 핫스팟을 컴파일해 성능과 유연성을 절충합니다.
- 가비지 컬렉션(GC): 마크·스윕, 참조 카운트, 세대별 GC

### 예제 (간단한 렉서/파서 예시 개념)

```text
입력: "1 + 2"
토큰화(Lexer): [NUM(1), PLUS, NUM(2)]
파서(Parser)는 AST: Add(1,2)
```

### 연습 문제

- 문제1: 인터프리터 방식과 JIT 방식의 장단점을 표로 정리하세요.
- 문제2: 참조 카운트 GC에서 순환 참조 문제를 해결하는 방법을 설명하세요.

### 정답 및 해설 (JS)

- 문제1 해답 (요약 표)

|방식|장점|단점|
|---|---:|---|
|인터프리터|즉시 실행, 디버깅 쉬움|느림|
|AOT|빠른 실행 시작, 예측 가능한 성능|유연성 낮음, 빌드 필요|
|JIT|핫스팟 최적화로 고성능|런타임 비용, 구현 복잡도|

- 문제2 해답: 순환 참조 해결

```js
// JS 환경에서는 WeakMap/WeakRef 사용을 권장
const a = {}; const b = {};
// 약한 참조로 순환을 끊음
const wm = new WeakMap();
wm.set(a, b);
wm.set(b, a);
// GC는 약한 참조만으로는 객체를 유지하지 않습니다.
```

설명: 참조 카운트는 순환 참조를 해제하지 못하므로 약한 참조(WeakRef, WeakMap)나 추적 기반 GC(마크·스윕)를 사용해 해결합니다.

## 운영체제(OS)

- 프로세스와 스레드: 주소공간, 컨텍스트 스위치
  - 설명: 프로세스는 독립된 주소공간을 가지는 실행 단위이고, 스레드는 동일 프로세스 내에서 경량 실행 흐름을 의미합니다. 컨텍스트 스위칭은 실행 흐름 전환 비용을 유발합니다.
- 스케줄링 알고리즘: FCFS, SJF, Round Robin, 우선순위 스케줄링
  - 설명: CPU 자원을 어떤 순서로 할당할지 결정하는 정책들로, 반응성·처리량·공정성 등 목표에 따라 선택됩니다.
- 동기화: 뮤텍스, 세마포어, 조건변수
  - 설명: 공유 자원 접근을 조율하기 위한 도구로, 경쟁 상태(race condition)를 방지합니다.
- 교착상태(Deadlock): 교착의 조건(상호배제, 점유대기, 비선점, 순환대기)
  - 설명: 여러 프로세스가 서로 자원을 기다려 진행 불가능한 상태입니다. 예방·회피·탐지·복구 전략이 존재합니다.
- 파일 시스템과 가상메모리(페이징, 스와핑)
  - 설명: 가상메모리는 물리 메모리보다 큰 주소 공간 제공, 페이징은 메모리를 고정 크기 블록으로 관리해 메모리 보호와 효율을 향상시킵니다.

### 예제 (의사코드: 뮤텍스 이용)

```text
mutex.lock()
// 공유 자원 접근
mutex.unlock()
```

### 연습 문제

- 문제1: 데드락의 네 가지 조건을 설명하고, 하나의 회피 전략을 구체적으로 예시로 제시하세요.
- 문제2: 컨텍스트 스위치가 성능에 미치는 영향을 설명하세요.

### 정답 및 해설 (JS)

- 문제1 해답: 네 가지 조건과 회피 전략(자원 계층화)

```text
네 가지 조건: 상호배제, 점유대기, 비선점, 순환대기
회피 전략(예시): 자원 계층화 - 모든 스레드는 정해진 자원 순서에 따라 락을 획득하도록 강제하여 순환대기를 방지.
```

- 문제2 해설: 컨텍스트 스위치 비용

```text
컨텍스트 스위치는 레지스터 저장/복원, TLB/캐시 영향, 커널 진입 비용 등이 있어 빈번하면 처리량 저하와 지연 증가를 초래합니다. 경량 작업(코루틴)으로 비용을 줄일 수 있습니다.
```

## 컴퓨터 구조 및 메모리

- CPU 아키텍처: 레지스터, 캐시(L1/L2/L3), 파이프라이닝, 분기 예측
  - 설명: 레지스터는 가장 빠른 저장소, 캐시는 자주 쓰이는 데이터를 보관해 메모리 지연을 줄입니다. 파이프라이닝은 명령어 처리 병렬화, 분기 예측은 분기 실패 비용을 낮춥니다.
- 메모리 계층: 레지스터 → 캐시 → 주기억장치 → 보조기억장치
  - 설명: 계층별로 접근 속도와 용량이 다르며, 데이터 지역성(locality)을 활용하면 성능이 개선됩니다.
- I/O: 인터럽트, DMA
  - 설명: 입출력 장치와 CPU 간 효율적 데이터 전송을 위해 인터럽트 기반 처리와 DMA(메모리 직접 접근)를 사용합니다.

### 예제 (캐시 지역성 설명)

```text
연속 메모리 예: for i in 0..n: sum += arr[i] // 순차 접근은 캐시 효율적
비연속 접근 예: for i in 0..n: sum += arr[rand()] // 캐시 미스 증가
```

### 연습 문제

- 문제1: L1/L2/L3 캐시의 차이와 역할을 간단히 정리하세요.
- 문제2: 배열 대신 링크드리스트를 사용할 때의 캐시 영향과 성능 결과를 논하세요.

### 정답 및 해설 (JS)

- 문제1 해답

```text
L1: 매우 작고 매우 빠름(코어당), L2: 중간 속도/크기, L3: 코어 공유 캐시(크지만 느림). 계층적 캐시로 접근 지연을 줄임.
```

- 문제2 해설 및 간단 벤치(JS 시뮬레이션)

```js
// 간단 시뮬레이션: 배열 순차 접근 vs 링크드리스트 노드 순회
function benchArray(n){
  const arr = new Array(n).fill(0).map((_,i)=>i);
  const t0 = Date.now();
  let s=0; for(let i=0;i<n;i++) s += arr[i];
  return Date.now()-t0;
}
function benchLinkedList(n){
  function Node(v, next=null){ this.v=v; this.next=next }
  let head = new Node(0);
  let cur = head;
  for(let i=1;i<n;i++){ cur.next = new Node(i); cur = cur.next }
  const t0 = Date.now();
  let s=0; cur = head;
  while(cur){ s += cur.v; cur = cur.next }
  return Date.now()-t0;
}
// 실제 JS 엔진 영향으로 결과는 환경마다 다르나 일반적으로 배열 순차 접근이 더 빠름
```

설명: 배열은 연속 메모리로 캐시 적중률이 좋아 빠르고, 링크드리스트는 포인터 따라가며 캐시 미스가 잦아 느립니다.

## 네트워킹 기초

- OSI와 TCP/IP 모델: 물리 ~ 응용 계층
  - 설명: 네트워크 통신을 계층별로 나눈 모델로, 각 계층은 서로 다른 책임(전송, 라우팅, 세션, 표현 등)을 가집니다.
- 주요 프로토콜: IP, TCP(연결형), UDP(비연결형), HTTP/HTTPS, DNS
  - 설명: IP는 라우팅, TCP는 신뢰성 있는 전송(재전송·흐름제어), UDP는 경량 전송(실시간성에 유리), HTTP/HTTPS는 응용계층의 주요 프로토콜입니다.
- 소켓 프로그래밍: TCP 소켓 vs UDP 소켓, 비동기 소켓
  - 설명: 소켓은 응용과 네트워크 스택을 연결하는 인터페이스입니다. 비동기 소켓은 논블로킹 I/O로 높은 동시성 처리에 유리합니다.
- REST vs gRPC: 텍스트 기반 HTTP API vs 프로토콜 버퍼 기반 RPC
  - 설명: REST는 단순성과 범용성, gRPC는 낮은 레이턴시와 엄격한 인터페이스(IDL) 및 이진 직렬화를 장점으로 가집니다.

### 예제 (간단한 TCP vs UDP 차이)

```text
TCP: 연결 수립 → 신뢰성 있는 전송(재전송, 순서 보장)
UDP: 비연결 → 낮은 오버헤드(순서/전송 보장 없음)
```

### 연습 문제

- 문제1: HTTP/2나 HTTP/3가 기존 HTTP/1.1에 비해 개선한 점을 정리하세요.
- 문제2: 소켓 프로그래밍으로 간단한 에코 서버(서버가 받은 메시지를 그대로 클라이언트에 반환)를 설계하세요(의사코드).

### 정답 및 해설 (JS)

- 문제1 해답

```text
HTTP/2: 멀티플렉싱(단일 커넥션으로 다중 스트림), 헤더 압축
HTTP/3: UDP 기반(QUIC)으로 핸드셰이크·재전송 개선 및 킬러 기능 제공
```

- 문제2 해답 (Node.js TCP 에코 서버)

```js
const net = require('net');
const server = net.createServer(socket => {
  socket.on('data', data => { socket.write(data); });
});
server.listen(4000, () => console.log('echo server on 4000'));
```

설명: 위 코드는 Node.js `net` 모듈로 TCP 소켓 에코 서버를 구현한 간단한 예입니다.

## 데이터베이스

- 관계형 DB(RDBMS): 스키마, 정규화, 트랜잭션(ACID), 인덱스
  - 설명: 테이블 기반 데이터 모델과 SQL을 사용합니다. 트랜잭션은 원자성·일관성·격리성·지속성을 보장합니다.
- NoSQL: 문서(DB: MongoDB), Key-Value, Wide-Column, 그래프 DB
  - 설명: 유연한 스키마나 높은 확장성, 특정 쿼리 패턴(예: 문서 검색, 시계열)에 특화된 데이터 저장소들입니다.
- 트랜잭션 격리 수준: Read Uncommitted → Serializable
  - 설명: 낮은 격리 수준은 동시성에서 더 높은 성능을 주지만 갱신 손실 같은 이상현상이 발생할 수 있습니다. Serializable은 직렬화 가능성을 보장합니다.
- 인덱스 설계: B-Tree, 해시 인덱스; 인덱스는 읽기 성능을 올리지만 쓰기 비용 증가
  - 설명: 인덱스는 탐색 속도를 높이나 인덱스 유지 관리 비용과 공간 오버헤드를 유발합니다. 쿼리 패턴을 기준으로 설계하세요.

### 예제 (SQL 인덱스 사용 예)

```sql
CREATE INDEX idx_users_email ON users(email);
SELECT * FROM users WHERE email = 'a@b.com'; -- 인덱스 활용
```

### 연습 문제

- 문제1: 트랜잭션 격리 수준 중 '갱신 손실'과 '팬텀 리드'를 정의하고 예를 드세요.
- 문제2: NoSQL이 RDBMS에 비해 유리한 도메인 사례 두 가지를 설명하세요.

### 정답 및 해설 (JS)

- 문제1 해답

```text
갱신 손실(Lost Update): 두 트랜잭션이 같은 데이터를 읽고 각각 갱신할 때 마지막 커밋이 첫 번째 갱신을 덮어써버리는 문제.
팬텀 리드(Phantom Read): 트랜잭션이 같은 쿼리를 두 번 실행했을 때 두 번째 실행에서 새로운 행(팬텀)이 나타나는 현상.
```

예시(의사코드):

```sql
-- T1: SELECT SUM(balance) FROM accounts WHERE type='savings';
-- T2: INSERT INTO accounts(type,balance) VALUES('savings',1000);
-- T1이 다시 쿼리하면 합계가 바뀌어 팬텀 리드 발생
```

- 문제2 해답

```text
1) 대규모 로그/이벤트 저장(쓰기 집약) - Key-Value나 Wide-Column이 적합
2) 유연한 스키마가 필요한 서비스(제품 카탈로그 등) - 문서 DB가 유리
```

## 소프트웨어 공학 및 설계

- 설계 원칙: SOLID, DRY, KISS, YAGNI
  - 설명: SOLID는 객체지향 설계의 5대 원칙(단일 책임, 개방-폐쇄 등), DRY는 중복 제거, KISS는 단순성 유지, YAGNI는 불필요한 기능 미구현을 권장합니다.
- 설계 패턴: 생성/구조/행동 패턴(Factory, Adapter, Strategy, Observer 등)
  - 설명: 재사용 가능한 설계 해법으로 코드의 유연성과 유지보수성을 높여 줍니다. 상황에 맞는 패턴 선택이 중요합니다.
- 아키텍처 스타일: 모놀리식, 마이크로서비스, 서버리스
  - 설명: 모놀리식은 단일 애플리케이션 단위, 마이크로서비스는 작은 서비스들의 집합으로 독립 배포·스케일링 가능, 서버리스는 인프라 관리를 최소화합니다.
- 도메인 주도 설계(DDD): 도메인 모델과 경계(boundary) 정의
  - 설명: 복잡한 도메인을 유비쿼터스 언어와 경계를 통해 모델링해 팀 간 의사소통과 설계를 개선합니다.

### 예제 (간단한 디자인 패턴 - Strategy)

```js
// Strategy 패턴: 알고리즘을 캡슐화하여 교체 가능
class SortStrategy { sort(arr) {} }
class QuickSort extends SortStrategy { sort(arr){ /* ... */ } }
class Context { setStrategy(s){ this.strategy = s } execute(arr){ return this.strategy.sort(arr) } }
```

### 연습 문제

- 문제1: SOLID 원칙 중 하나(Single Responsibility Principle)를 코드 예시와 함께 설명하세요.
- 문제2: 마이크로서비스로 분리할 때 주의할 점(데이터 일관성, 트랜잭션)을 세 가지 적으세요.

### 정답 및 해설 (JS)

- 문제1 해답 (SRP 예시)

```js
// SRP 위반 예
class UserService {
  createUser(data){ /* DB 저장 */ }
  renderUserHTML(user){ /* HTML 생성 */ }
}

// SRP 준수: 책임 분리
class UserRepository { create(user){ /* DB 저장 */ } }
class UserRenderer { render(user){ /* HTML 생성 */ } }
```

- 문제2 해답

```text
1) 데이터 일관성: 분산 트랜잭션 대신 이벤트 소싱/CQRS 고려
2) 서비스 간 통신 실패에 대한 폴백/재시도 전략 필요
3) 모니터링·로그/분산 추적(예: OpenTelemetry) 필수
```

## 테스트·배포·CI/CD

- 테스트 종류: 유닛, 통합, E2E, 성능 테스트
  - 설명: 유닛 테스트는 개별 모듈 검증, 통합 테스트는 모듈 간 상호작용 검증, E2E는 사용자 시나리오 전체 검증, 성능 테스트는 부하/지연 측정에 사용됩니다.
- CI/CD: 자동 빌드 → 테스트 → 배포 파이프라인 (GitHub Actions, GitLab CI 등)
  - 설명: 코드 변경 시 자동화된 파이프라인으로 품질을 보장하고 배포 속도를 높입니다. PR 기반 워크플로와 코드 리뷰를 통합하세요.
- 블루/그린 배포, 카나리 배포 전략
  - 설명: 블루/그린은 두 환경을 둬 트래픽을 전환하며 배포 리스크를 줄이고, 카나리는 일부 트래픽으로 새 버전을 점진적 검증합니다.

### 예제 (GitHub Actions 워크플로우 스니펫)

```yaml
name: CI
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install
        run: npm ci
      - name: Test
        run: npm test
```

### 연습 문제

- 문제1: 카나리 배포를 구현할 때 트래픽 분할 및 모니터링 전략을 간단히 설계하세요.
- 문제2: 단위 테스트와 통합 테스트의 경계를 실제 예로 설명하세요.

### 정답 및 해설 (JS)

- 문제1 해답 (간단 설계)

```text
1) 트래픽 분할: 로드밸런서에서 5% 트래픽을 새 버전으로 라우팅
2) 모니터링: 응답시간, 오류율, 비즈니스 지표(주문 건수) 관찰
3) 자동 롤백: 오류율 임계치 초과 시 트래픽 원복
```

- 문제2 해답 (JS 예)

```js
// 단위 테스트: 순수 함수 검증
function add(a,b){ return a+b }
// Jest 단위 테스트 예
// test('adds', ()=> expect(add(1,2)).toBe(3))

// 통합 테스트: HTTP 레이어 + DB를 함께 검증
// supertest를 이용해 API 엔드포인트를 띄우고 실제 DB(또는 테스트 DB)에 데이터가 저장되는지 확인
```

## 보안 기초

- 인증·인가: OAuth, JWT, 세션 관리
  - 설명: 인증은 사용자를 확인하고, 인가는 권한을 결정합니다. OAuth는 권한 위임 프로토콜, JWT는 자체 포함 토큰 형식을 제공합니다.
- 암호화: 대칭키·비대칭키, TLS(HTTPS)
  - 설명: 대칭키는 같은 키로 암복호화, 비대칭키는 공개/비밀키 쌍을 사용합니다. TLS는 전송 계층 보안을 제공해 중간자 공격을 방지합니다.
- 취약점: SQL 인젝션, XSS, CSRF, 취약한 직렬화
  - 설명: 입력 검증과 출력 이스케이프, 적절한 권한 체크로 대부분의 웹 취약점을 완화할 수 있습니다.
- 보안 실무: 최소 권한 원칙, 비밀(Secrets) 관리, 정기적인 취약점 스캔

### 예제 (SQL 인젝션 방지 - 준비문 사용)

```js
// Node.js (의사코드)
db.query('SELECT * FROM users WHERE id = ?', [userInput]) // 준비문 사용으로 인젝션 방지
```

### 연습 문제

- 문제1: OAuth의 Authorization Code 흐름을 단계별로 설명하세요.
- 문제2: CSRF 공격을 방지하는 방법 두 가지를 설명하고 구현 아이디어를 제시하세요.

### 정답 및 해설 (JS)

- 문제1 해답 (요약)

```text
1) 클라이언트가 권한 요청(redirect) → 2) 사용자 인증 및 허가 → 3) 인증서버가 authorization code 발급(redirect back)
4) 클라이언트는 코드로 토큰 교환 → 5) 액세스 토큰으로 리소스 서버 접근
```

- 문제2 해답 (실무적 구현 아이디어 - JS)

```js
// 1) CSRF 토큰 방식: 서버가 세션에 토큰 저장, 폼에 숨겨서 전송, 서버에서 검증
// 2) SameSite 쿠키 설정: Set-Cookie: session=...; SameSite=Strict

// 예: express + csurf 미들웨어 사용 권장
```

## 추천 학습 흐름과 참고자료

- 기초: 이산수학, 자료구조, 알고리즘(문제 풀이로 체화)
  - 설명: 구조적 사고와 복잡도 감각을 키우는 단계입니다. 문제 풀이(예: 알고리즘 사이트)를 통해 손으로 설계·분석하는 연습을 권장합니다.
- 중급: 운영체제, 컴퓨터 구조, 네트워크, 데이터베이스
  - 설명: 시스템의 동작 원리와 병목을 이해하고 효율적인 설계를 할 수 있게 됩니다.
- 고급: 분산 시스템, 컴파일러, 보안, 머신러닝(도메인별 특화)
  - 설명: 특정 도메인에서 깊이 있는 아키텍처와 이론을 적용할 수 있는 수준입니다.
- 서적/리소스: CLRS(알고리즘), TAOCP(고급 알고리즘), Operating Systems: Three Easy Pieces, Computer Networking: A Top-Down Approach
  - 설명: 각 책은 해당 분야의 권위 있는 레퍼런스로, 학습 커리큘럼에 포함시키기 좋습니다.

### 실습 플랜(예시)

- 1~3개월: 자료구조와 알고리즘(주 3회 문제 풀이)
- 4~6개월: 운영체제·네트워크·데이터베이스(각각 실습 프로젝트)
- 이후: 분산 시스템·보안 등 도메인 특화 학습 및 개인 프로젝트

### 연습 문제

- 문제1: 위 실습 플랜을 기준으로 6개월 목표를 세우고, 매주 할 일을 3개 적어보세요.
- 문제2: 추천 서적 중 한 권을 골라 독서 계획(챕터 단위)을 작성하세요.

### 정답 및 해설 (예시)

- 문제1 예시(6개월 목표)

```text
월1-3: 자료구조/알고리즘 집중 - 매주 3문제(자료구조/정렬/탐색) + 1 이론 강독
월4-6: OS/DB/네트워크 실습 - 간단한 프로젝트(예: 채팅 서버) + 개념 복습
```

- 문제2 예시: CLRS(알고리즘)

```text
1주차: Chapter1-2(기초, 수학적 도구)
2주차: Chapter3-4(정렬, 탐색)
... (챕터별로 1~2주 할당)
```

설명: 위는 템플릿 예시이며, 개인 시간 여건에 따라 조정하세요.

## 맺음말

이 요약은 실무에서 자주 마주치는 개념들을 한데 모은 정리입니다. 더 깊은 예제, 연습 문제, 또는 특정 주제(예: 분산 트랜잭션, 메모리 모델, 특정 언어의 내부 동작)를 원하시면 분량별로 세부 문서를 추가로 작성해 드리겠습니다.

---
작성일: 2026-02-15
