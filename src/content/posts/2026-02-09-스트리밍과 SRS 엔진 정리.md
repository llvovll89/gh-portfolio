---
title: 스트리밍과 SRS 엔진 정리
date: 2026-02-09
summary: 스트리밍 기초 개념부터 SRS(Simple Realtime Server) 엔진 설치, 설정, 프로토콜별 송출·재생, 서버 운영까지 실무 중심 총정리
tags: [streaming, srs, rtmp, hls, webrtc, http-flv, nginx, live, media-server]
---

# 스트리밍과 SRS 엔진 정리 (실무 중심)

**SRS(Simple Realtime Server)**는 오픈소스 실시간 미디어 서버로, RTMP · HLS · HTTP-FLV · WebRTC · SRT · MPEG-DASH 등 주요 스트리밍 프로토콜을 모두 지원합니다.

> 목표: 스트리밍 **기초 개념** 이해 → SRS **설치·설정** → **프로토콜별 송출/재생** → **서버 운영·배포**까지 한 문서로 정리

---

## 목차

1) 스트리밍 기초 개념
2) 주요 프로토콜 비교
3) SRS 엔진 개요
4) SRS 설치 및 실행
5) SRS 핵심 설정 (srs.conf)
6) 스트림 송출 (Publish)
7) 스트림 재생 (Play) — 프로토콜별 주소 구조
8) WebRTC 연동
9) 녹화(DVR) 및 HLS 설정
10) Nginx 리버스 프록시 + SSL
11) Docker 기반 배포
12) 클러스터 & Edge 구성
13) 모니터링 & API
14) 트러블슈팅 & 실무 팁

---

## 1. 스트리밍 기초 개념

### 스트리밍 vs 다운로드

| 구분 | 스트리밍 | 다운로드 |
|------|---------|---------|
| 재생 시점 | 수신과 동시에 재생 | 완료 후 재생 |
| 저장 | 일시적 버퍼 | 파일 영구 저장 |
| 지연(Latency) | 낮거나 거의 없음 | 해당 없음 |

### 스트리밍 유형

| 유형 | 설명 | 대표 사례 |
|------|------|----------|
| **라이브 스트리밍** | 실시간 송출, 즉시 시청 | 방송, CCTV, 화상회의 |
| **VOD(Video On Demand)** | 미리 저장된 영상을 요청 시 재생 | 넷플릭스, 유튜브 |
| **Low-Latency Live** | 1초 이내 초저지연 라이브 | 경매, 스포츠 베팅, 인터랙티브 |

### 핵심 용어

| 용어 | 설명 |
|------|------|
| **인코딩(Encoding)** | 원본 영상을 코덱(H.264, H.265, VP9, AV1 등)으로 압축 |
| **트랜스코딩(Transcoding)** | 코덱/해상도/비트레이트를 다른 형식으로 변환 |
| **먹싱(Muxing)** | 영상+오디오 트랙을 하나의 컨테이너(FLV, TS, MP4)로 묶기 |
| **CDN** | Content Delivery Network, 지리적 분산 캐시 |
| **Origin / Edge** | Origin: 원본 서버 / Edge: 사용자에게 가까운 중계 서버 |
| **비트레이트(Bitrate)** | 초당 전송 데이터량 (예: 4Mbps) |
| **키프레임(Keyframe)** | 전체 화면 정보를 담은 프레임 (I-Frame), GOP의 시작 |
| **GOP(Group of Pictures)** | 키프레임 간격, 보통 1~2초 |

---

## 2. 주요 프로토콜 비교

| 프로토콜 | 전송 방식 | 지연(Latency) | 장점 | 단점 |
|----------|----------|:------------:|------|------|
| **RTMP** | TCP, 포트 1935 | 1~3초 | 안정적 송출, 범용 인코더 지원 | 브라우저 재생 불가 (Flash 종료) |
| **HLS** | HTTP (TS/fMP4 세그먼트) | 6~30초 | 모든 브라우저/CDN 호환 | 지연 높음 |
| **LL-HLS** | HTTP + Partial Segments | 2~4초 | 표준 HLS와 호환, 저지연 | 설정 복잡 |
| **HTTP-FLV** | HTTP Long Polling | 1~3초 | 낮은 지연, 브라우저 재생 가능 | iOS Safari 미지원 |
| **WebRTC** | UDP (SRTP/SCTP) | ~0.5초 | 초저지연, P2P/SFU | 대규모 배포 CDN 어려움 |
| **SRT** | UDP + ARQ | 0.5~2초 | 불안정 네트워크에서 안정적 | 브라우저 미지원 |
| **MPEG-DASH** | HTTP (세그먼트) | 6~30초 | 국제 표준, ABR 지원 | HLS 대비 점유율 낮음 |

### 실무에서의 일반적 조합

```
[인코더/카메라]
     │
     │ RTMP (송출)
     ▼
 ┌─────────┐
 │   SRS   │  ← Origin 서버
 └────┬────┘
      │
      ├── HLS        → 범용 재생 (모바일, 웹)
      ├── HTTP-FLV   → 저지연 웹 재생
      ├── WebRTC     → 초저지연 재생
      └── RTMP       → 다른 서버로 릴레이
```

---

## 3. SRS 엔진 개요

### SRS란?

- **Simple Realtime Server** — C++로 작성된 오픈소스 미디어 서버
- GitHub: `ossrs/srs`
- 라이선스: MIT
- 현재 주력 버전: **SRS 5.x** (SRS 6.x 개발 중)

### SRS 아키텍처

```
                    ┌───────────────────────────┐
  RTMP Publish ───▶ │                           │ ──▶ RTMP Play
  SRT  Publish ───▶ │         SRS Server        │ ──▶ HLS (.m3u8)
  WebRTC Push  ───▶ │                           │ ──▶ HTTP-FLV
                    │  ┌─────┐  ┌──────┐       │ ──▶ WebRTC Play
                    │  │Conf │  │ HTTP │       │ ──▶ SRT Play
                    │  │     │  │ API  │       │ ──▶ MPEG-DASH
                    │  └─────┘  └──────┘       │
                    └───────────────────────────┘
                         ▲            │
                     srs.conf     :1985 API
                                  :8080 Console
```

### SRS vs 다른 미디어 서버

| 서버 | 언어 | 특징 |
|------|------|------|
| **SRS** | C++ | 경량, 고성능, 설정 단순, 프로토콜 풍부 |
| **Nginx-RTMP** | C | Nginx 모듈, RTMP+HLS만 지원 |
| **MediaMTX** | Go | 경량, 다중 프로토콜, 설정 간단 |
| **Wowza** | Java | 상용, 엔터프라이즈 기능 풍부 |
| **Janus** | C | WebRTC 전문 게이트웨이 |
| **Ant Media** | Java | WebRTC+RTMP, 오픈소스+상용 |

---

## 4. SRS 설치 및 실행

### 4-1. Docker (권장)

```bash
# 최신 SRS 5 실행
docker run --rm -it \
  -p 1935:1935 \
  -p 1985:1985 \
  -p 8080:8080 \
  -p 8000:8000/udp \
  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \
  ./objs/srs -c conf/srs.conf

# 또는 Docker Hub
docker run --rm -it \
  -p 1935:1935 \
  -p 1985:1985 \
  -p 8080:8080 \
  -p 8000:8000/udp \
  ossrs/srs:5
```

**포트 정리**

| 포트 | 프로토콜 | 용도 |
|------|---------|------|
| 1935 | TCP | RTMP 송출/재생 |
| 1985 | TCP | HTTP API |
| 8080 | TCP | HTTP 서버 (HLS, HTTP-FLV, 콘솔) |
| 8000 | UDP | WebRTC (WHIP/WHEP) |

### 4-2. 소스 빌드 (Linux)

```bash
git clone -b 5.0release https://github.com/ossrs/srs.git
cd srs/trunk

./configure
make -j$(nproc)

# 실행
./objs/srs -c conf/srs.conf

# 상태 확인
./etc/init.d/srs status
```

### 4-3. 실행 확인

```bash
# API로 상태 확인
curl http://localhost:1985/api/v1/versions

# 콘솔 접속 (브라우저)
# http://localhost:8080
```

---

## 5. SRS 핵심 설정 (srs.conf)

### 기본 구조

```nginx
# 전역 설정
listen              1935;        # RTMP 포트
max_connections     1000;
daemon              off;         # Docker에서는 off 권장
srs_log_tank        console;     # 로그를 콘솔로

# HTTP API
http_api {
    enabled     on;
    listen      1985;
}

# HTTP 서버 (HLS, HTTP-FLV 등)
http_server {
    enabled     on;
    listen      8080;
    dir         ./objs/nginx/html;
}

# WebRTC
rtc_server {
    enabled     on;
    listen      8000;              # UDP
    candidate   *;                 # 외부 IP 또는 * (자동)
}

# vhost 설정
vhost __defaultVhost__ {
    # HLS
    hls {
        enabled     on;
        hls_fragment    2;         # 세그먼트 길이 (초)
        hls_window      10;        # 재생 목록 유지 시간 (초)
        hls_path        ./objs/nginx/html;
        hls_m3u8_file   [app]/[stream].m3u8;
        hls_ts_file     [app]/[stream]-[seq].ts;
    }

    # HTTP-FLV
    http_remux {
        enabled     on;
        mount       [vhost]/[app]/[stream].flv;
    }

    # WebRTC
    rtc {
        enabled     on;
        rtmp_to_rtc on;           # RTMP→WebRTC 자동 변환
        rtc_to_rtmp on;           # WebRTC→RTMP 자동 변환
    }

    # DVR (녹화)
    dvr {
        enabled         off;
        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;
        dvr_plan        session;   # session | segment
    }
}
```

### 주요 설정 옵션 해설

| 설정 | 설명 | 기본값 |
|------|------|--------|
| `listen` | RTMP 수신 포트 | 1935 |
| `max_connections` | 최대 동시 연결 수 | 1000 |
| `daemon` | 백그라운드 실행 여부 | on |
| `candidate` | WebRTC ICE 후보 주소 (서버 공인 IP) | * |
| `hls_fragment` | TS 세그먼트 길이 (초) | 10 |
| `hls_window` | m3u8 재생 목록 길이 (초) | 60 |
| `rtmp_to_rtc` | RTMP 입력을 WebRTC로 자동 제공 | off |
| `rtc_to_rtmp` | WebRTC 입력을 RTMP로 자동 변환 | off |

---

## 6. 스트림 송출 (Publish)

### 6-1. RTMP 송출

**FFmpeg으로 송출**

```bash
# 파일을 라이브 스트림으로 송출
ffmpeg -re -i input.mp4 \
  -c:v libx264 -preset veryfast -tune zerolatency \
  -c:a aac -ar 44100 -b:a 128k \
  -f flv rtmp://<서버IP>:1935/live/stream01

# 웹캠 + 마이크 (Linux)
ffmpeg -f v4l2 -i /dev/video0 \
  -f pulse -i default \
  -c:v libx264 -preset ultrafast -tune zerolatency \
  -c:a aac \
  -f flv rtmp://<서버IP>:1935/live/camera01
```

**OBS Studio 설정**

| 항목 | 값 |
|------|---|
| 서비스 | 사용자 지정 |
| 서버 | `rtmp://<서버IP>:1935/live` |
| 스트림 키 | `stream01` (자유 지정) |
| 인코더 | x264 또는 하드웨어 인코더 |
| 비트레이트 | 2500~6000 Kbps |
| 키프레임 간격 | 2초 |

### RTMP 주소 구조

```
rtmp://<host>:<port>/<app>/<stream>

예시: rtmp://192.168.0.100:1935/live/stream01
       │          │          │    │     │
       프로토콜   서버IP      포트  앱    스트림키
```

- **app**: 논리적 경로 그룹 (보통 `live`, `vod` 등 자유 지정)
- **stream**: 개별 스트림 식별자 (자유 지정)

### 6-2. SRT 송출

```bash
ffmpeg -re -i input.mp4 \
  -c:v libx264 -preset veryfast \
  -c:a aac \
  -f mpegts "srt://<서버IP>:10080?streamid=#!::r=live/stream01,m=publish"
```

srs.conf에 SRT 설정 추가:

```nginx
srt_server {
    enabled     on;
    listen      10080;
}
```

### 6-3. WebRTC 송출 (WHIP)

```bash
# WHIP (WebRTC-HTTP Ingestion Protocol) 엔드포인트
# 브라우저 또는 WHIP 클라이언트에서:
POST http://<서버IP>:1985/rtc/v1/whip/?app=live&stream=stream01
Content-Type: application/sdp

# Body: SDP Offer
```

브라우저에서 SRS 콘솔의 WHIP 데모 페이지를 통해 WebRTC로 직접 송출 가능:

```
http://<서버IP>:8080/players/whip.html
```

---

## 7. 스트림 재생 (Play) — 프로토콜별 주소 구조

RTMP로 `rtmp://<IP>:1935/live/stream01`에 송출했다고 가정했을 때, 각 프로토콜로 재생하는 주소는 다음과 같습니다.

### 주소 총정리 표

| 프로토콜 | 재생 주소 | 용도 |
|----------|----------|------|
| **RTMP** | `rtmp://<IP>:1935/live/stream01` | VLC, ffplay |
| **HLS** | `http://<IP>:8080/live/stream01.m3u8` | 브라우저, 모바일 앱 |
| **HTTP-FLV** | `http://<IP>:8080/live/stream01.flv` | flv.js 웹 플레이어 |
| **WebRTC (WHEP)** | `http://<IP>:1985/rtc/v1/whep/?app=live&stream=stream01` | 브라우저 초저지연 |
| **SRT** | `srt://<IP>:10080?streamid=#!::r=live/stream01,m=request` | SRT 플레이어 |

### 7-1. RTMP 재생

```bash
# FFplay
ffplay rtmp://<IP>:1935/live/stream01

# VLC
# 미디어 → 네트워크 스트림 열기
# rtmp://<IP>:1935/live/stream01
```

### 7-2. HLS 재생

```bash
# FFplay
ffplay http://<IP>:8080/live/stream01.m3u8

# 브라우저 (hls.js 사용)
```

```html
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<video id="video" controls autoplay></video>
<script>
  const video = document.getElementById('video');
  if (Hls.isSupported()) {
    const hls = new Hls();
    hls.loadSource('http://<IP>:8080/live/stream01.m3u8');
    hls.attachMedia(video);
  } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
    // iOS Safari 네이티브 HLS
    video.src = 'http://<IP>:8080/live/stream01.m3u8';
  }
</script>
```

### 7-3. HTTP-FLV 재생

```html
<script src="https://cdn.jsdelivr.net/npm/flv.js@latest"></script>
<video id="video" controls autoplay></video>
<script>
  if (flvjs.isSupported()) {
    const player = flvjs.createPlayer({
      type: 'flv',
      url: 'http://<IP>:8080/live/stream01.flv'
    });
    player.attachMediaElement(document.getElementById('video'));
    player.load();
    player.play();
  }
</script>
```

> HTTP-FLV는 **라이브 저지연 웹 재생**에 많이 사용됩니다. HLS보다 지연이 훨씬 낮고, flv.js로 `<video>` 태그에서 재생 가능합니다.

### 7-4. WebRTC 재생 (WHEP)

```html
<video id="video" autoplay playsinline></video>
<script>
  async function play() {
    const pc = new RTCPeerConnection();
    pc.addTransceiver('audio', { direction: 'recvonly' });
    pc.addTransceiver('video', { direction: 'recvonly' });

    pc.ontrack = (event) => {
      document.getElementById('video').srcObject = event.streams[0];
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const res = await fetch(
      'http://<IP>:1985/rtc/v1/whep/?app=live&stream=stream01',
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/sdp' },
        body: offer.sdp
      }
    );

    const answerSDP = await res.text();
    await pc.setRemoteDescription(
      new RTCSessionDescription({ type: 'answer', sdp: answerSDP })
    );
  }

  play();
</script>
```

---

## 8. WebRTC 연동 심화

### RTMP → WebRTC 자동 변환

srs.conf에서 `rtmp_to_rtc on;`이면, RTMP로 송출된 스트림을 WebRTC로 바로 재생할 수 있습니다.

```nginx
vhost __defaultVhost__ {
    rtc {
        enabled     on;
        rtmp_to_rtc on;
        rtc_to_rtmp on;
    }
}
```

### candidate 설정 (중요)

서버가 NAT 뒤에 있거나 공인 IP와 다른 경우, `candidate`를 명시해야 WebRTC가 정상 동작합니다.

```nginx
rtc_server {
    enabled     on;
    listen      8000;
    candidate   123.456.789.0;   # 공인 IP 명시
}
```

환경변수로 동적 설정 (Docker):

```bash
docker run --rm -it \
  -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 8000:8000/udp \
  -e CANDIDATE="<공인IP>" \
  ossrs/srs:5 \
  ./objs/srs -c conf/docker.conf
```

### WHIP / WHEP 표준

| 규격 | 용도 | HTTP 메서드 | 엔드포인트 |
|------|------|:-----------:|-----------|
| **WHIP** | 송출 (Publish) | POST | `/rtc/v1/whip/?app=live&stream=xxx` |
| **WHEP** | 재생 (Play) | POST | `/rtc/v1/whep/?app=live&stream=xxx` |

---

## 9. 녹화(DVR) 및 HLS 고급 설정

### DVR (녹화)

```nginx
vhost __defaultVhost__ {
    dvr {
        enabled         on;
        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;
        dvr_plan        session;    # session: 세션 전체 1파일
                                    # segment: 일정 간격으로 분할
        dvr_duration    30;         # segment 모드일 때 파일 길이(초)
        dvr_wait_keyframe on;       # 키프레임에서 분할
    }
}
```

### HLS 저지연 설정

```nginx
vhost __defaultVhost__ {
    hls {
        enabled         on;
        hls_fragment    2;      # 2초 세그먼트 (낮을수록 저지연, 최소 1)
        hls_window      6;      # 재생 목록에 세그먼트 약 3개 유지
        hls_path        ./objs/nginx/html;
        hls_m3u8_file   [app]/[stream].m3u8;
        hls_ts_file     [app]/[stream]-[seq].ts;
        hls_cleanup     on;     # 오래된 ts 파일 자동 삭제
        hls_dispose     30;     # 스트림 종료 후 파일 유지 시간(초)
    }
}
```

### HLS + aes128 암호화

```nginx
vhost __defaultVhost__ {
    hls {
        enabled     on;
        hls_keys    on;
        hls_fragments_per_key 5;   # 키 갱신 간격
        hls_key_file    [app]/[stream]-[seq].key;
        hls_key_file_path ./objs/nginx/html;
        hls_key_url     /[app]/[stream]-[seq].key;
    }
}
```

---

## 10. Nginx 리버스 프록시 + SSL

### 왜 Nginx를 앞에 두는가?

- SRS HTTP 서버는 기본적으로 TLS를 직접 처리하지 않음
- Nginx에서 **SSL 종료(TLS Termination)** 처리 → SRS에 HTTP로 전달
- 도메인 기반 라우팅, 캐싱, 접근 제어 등 부가 기능

### Nginx 설정 예시

```nginx
# /etc/nginx/conf.d/srs.conf

# HTTP → HTTPS 리다이렉트
server {
    listen 80;
    server_name live.example.com;
    return 301 https://$host$request_uri;
}

# HTTPS (HLS, HTTP-FLV, API)
server {
    listen 443 ssl http2;
    server_name live.example.com;

    ssl_certificate     /etc/letsencrypt/live/live.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/live.example.com/privkey.pem;

    # HLS 재생
    location /live/ {
        proxy_pass http://127.0.0.1:8080/live/;
        proxy_set_header Host $host;

        # CORS (웹 플레이어 접근 허용)
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, OPTIONS";
    }

    # HTTP-FLV 재생 (청크 전송 필수)
    location ~ \.flv$ {
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;

        proxy_buffering off;          # 버퍼링 비활성화 (실시간)
        chunked_transfer_encoding on;
    }

    # SRS HTTP API
    location /api/ {
        proxy_pass http://127.0.0.1:1985/api/;
        proxy_set_header Host $host;
    }

    # SRS 콘솔
    location /console/ {
        proxy_pass http://127.0.0.1:8080/console/;
    }

    # WebRTC WHEP/WHIP (API 경로)
    location /rtc/ {
        proxy_pass http://127.0.0.1:1985/rtc/;
        proxy_set_header Host $host;
    }
}
```

### SSL 적용 후 주소 변경

| 프로토콜 | Before | After |
|----------|--------|-------|
| HLS | `http://<IP>:8080/live/stream01.m3u8` | `https://live.example.com/live/stream01.m3u8` |
| HTTP-FLV | `http://<IP>:8080/live/stream01.flv` | `https://live.example.com/live/stream01.flv` |
| API | `http://<IP>:1985/api/v1/...` | `https://live.example.com/api/v1/...` |
| WHEP | `http://<IP>:1985/rtc/v1/whep/...` | `https://live.example.com/rtc/v1/whep/...` |

> RTMP 송출 주소는 변경 없음: `rtmp://<IP>:1935/live/stream01` (RTMPS가 필요하면 stunnel 등 별도 설정)

### Let's Encrypt SSL 인증서 발급

```bash
# Certbot 설치 (Ubuntu)
sudo apt install certbot python3-certbot-nginx

# 인증서 발급 + Nginx 자동 설정
sudo certbot --nginx -d live.example.com

# 자동 갱신 테스트
sudo certbot renew --dry-run
```

---

## 11. Docker 기반 배포

### docker-compose.yml

```yaml
version: "3.8"

services:
  srs:
    image: ossrs/srs:5
    container_name: srs-server
    restart: always
    ports:
      - "1935:1935"     # RTMP
      - "1985:1985"     # HTTP API
      - "8080:8080"     # HTTP Server (HLS, FLV)
      - "8000:8000/udp" # WebRTC
    volumes:
      - ./conf/srs.conf:/usr/local/srs/conf/srs.conf
      - ./objs/nginx/html:/usr/local/srs/objs/nginx/html
    environment:
      - CANDIDATE=${PUBLIC_IP}
    command: ./objs/srs -c conf/srs.conf

  nginx:
    image: nginx:alpine
    container_name: srs-nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    depends_on:
      - srs
```

### 실행

```bash
# .env 파일에 공인 IP 설정
echo "PUBLIC_IP=123.456.789.0" > .env

# 실행
docker compose up -d

# 로그 확인
docker compose logs -f srs
```

---

## 12. 클러스터 & Edge 구성

### Origin-Edge 구조

사용자 수가 많아지면 단일 SRS로는 한계가 있습니다. Origin-Edge 구조로 수평 확장할 수 있습니다.

```
[인코더]
   │ RTMP
   ▼
┌──────────┐         ┌──────────┐
│  Origin  │◀───────▶│  Edge 1  │ ──▶ 재생 클라이언트들
│  (SRS)   │         │  (SRS)   │
└──────────┘         └──────────┘
      ▲              ┌──────────┐
      └──────────────▶│  Edge 2  │ ──▶ 재생 클라이언트들
                      │  (SRS)   │
                      └──────────┘
```

### Origin 서버 설정

```nginx
# origin.conf
listen 1935;

vhost __defaultVhost__ {
    cluster {
        mode    local;     # Origin 모드
        origin_cluster on; # Origin 간 클러스터링
    }

    hls {
        enabled on;
    }

    rtc {
        enabled     on;
        rtmp_to_rtc on;
    }
}
```

### Edge 서버 설정

```nginx
# edge.conf
listen 1935;

vhost __defaultVhost__ {
    cluster {
        mode    remote;                    # Edge 모드
        origin  <Origin_IP>:1935;          # Origin 주소
    }

    hls {
        enabled on;
    }

    rtc {
        enabled     on;
        rtmp_to_rtc on;
    }
}
```

> Edge는 클라이언트 요청이 들어올 때 자동으로 Origin에서 스트림을 가져옵니다 (Lazy Pull).

### Forward (스트림 전달)

한 Origin에서 다른 서버로 자동 전달:

```nginx
vhost __defaultVhost__ {
    forward {
        enabled  on;
        destination  <다른서버IP>:1935;
    }
}
```

---

## 13. 모니터링 & API

### SRS HTTP API 주요 엔드포인트

| 엔드포인트 | 설명 |
|-----------|------|
| `GET /api/v1/versions` | SRS 버전 정보 |
| `GET /api/v1/summaries` | 서버 요약 (CPU, 메모리, 연결 수) |
| `GET /api/v1/vhosts` | vhost 목록 |
| `GET /api/v1/streams` | 활성 스트림 목록 |
| `GET /api/v1/clients` | 접속 클라이언트 목록 |
| `DELETE /api/v1/clients/{id}` | 특정 클라이언트 강제 종료 |

### 스트림 상태 확인

```bash
# 현재 활성 스트림 목록
curl http://localhost:1985/api/v1/streams | jq

# 응답 예시 (간략화)
{
  "streams": [
    {
      "id": "vid-xxx",
      "name": "stream01",
      "app": "live",
      "live_ms": 123456,
      "clients": 5,
      "kbps": {
        "recv_30s": 2500,
        "send_30s": 12500
      },
      "publish": {
        "active": true
      },
      "video": {
        "codec": "H264",
        "width": 1920,
        "height": 1080
      },
      "audio": {
        "codec": "AAC",
        "sample_rate": 44100,
        "channel": 2
      }
    }
  ]
}
```

### SRS 콘솔 (웹 대시보드)

```
http://<서버IP>:8080/console/
```

- 실시간 스트림/클라이언트 모니터링
- 서버 리소스 사용량 확인
- 스트림 재생 테스트

### Callback (Webhook)

SRS는 이벤트 발생 시 HTTP Callback을 보낼 수 있습니다:

```nginx
vhost __defaultVhost__ {
    http_hooks {
        enabled     on;
        # 인증: 송출 시작 전 호출 → 200이면 허용, 그 외 거부
        on_publish  http://your-api-server/api/srs/on_publish;
        # 재생 시작
        on_play     http://your-api-server/api/srs/on_play;
        # 송출 종료
        on_unpublish http://your-api-server/api/srs/on_unpublish;
        # 재생 종료
        on_stop     http://your-api-server/api/srs/on_stop;
        # DVR 녹화 완료
        on_dvr      http://your-api-server/api/srs/on_dvr;
        # HLS 세그먼트 생성
        on_hls      http://your-api-server/api/srs/on_hls;
    }
}
```

**Callback 요청 데이터 예시 (on_publish)**

```json
{
  "action": "on_publish",
  "client_id": "xxx",
  "ip": "192.168.0.10",
  "vhost": "__defaultVhost__",
  "app": "live",
  "stream": "stream01",
  "tcUrl": "rtmp://192.168.0.100:1935/live",
  "pageUrl": ""
}
```

> 이를 활용하면 **스트림 인증**, **접속 기록**, **자동 녹화 트리거** 등을 외부 서버에서 처리할 수 있습니다.

---

## 14. 트러블슈팅 & 실무 팁

### 자주 겪는 문제와 해결

| 증상 | 원인 | 해결 |
|------|------|------|
| RTMP 송출은 되지만 HLS 재생 안 됨 | `hls { enabled off; }` | srs.conf에서 `hls { enabled on; }` 확인 |
| WebRTC 재생 시 연결 실패 | candidate 설정 누락 또는 NAT/방화벽 | `candidate`에 공인 IP 명시, UDP 8000 포트 개방 |
| WebRTC 영상은 나오나 음성 없음 | 오디오 코덱 미지원 (Opus↔AAC) | `rtmp_to_rtc on;` 확인 (SRS가 자동 트랜스코딩) |
| HLS 재생 시 지연이 30초 이상 | hls_fragment / hls_window 너무 큼 | `hls_fragment 2; hls_window 6;` 으로 줄이기 |
| HTTP-FLV 재생이 끊김 | Nginx 버퍼링 | `proxy_buffering off;` 설정 |
| 동시 접속 많으면 끊김 | max_connections 초과 | `max_connections` 늘리기 + Edge 분산 |
| RTMP 송출 시 "connection refused" | 1935 포트 미개방 | 방화벽/보안그룹에서 TCP 1935 개방 |

### 성능 최적화 팁

1. **GOP 크기 최적화**: 인코더에서 키프레임 간격을 2초로 설정하면 HLS 세그먼트를 2초까지 줄일 수 있습니다.

2. **비트레이트 제어**: 네트워크에 맞게 CBR(고정)로 설정하면 안정적, VBR(가변)은 화질은 좋지만 불안정한 네트워크에서 끊길 수 있습니다.

3. **코덱 선택**:
   - H.264 + AAC: 가장 호환성 높음 (권장)
   - H.265(HEVC): 대역폭 절약, 그러나 브라우저 지원 제한
   - Opus: WebRTC 기본 오디오 코덱

4. **커널 파라미터 튜닝** (대규모 서비스):

```bash
# /etc/sysctl.conf
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_tw_reuse = 1
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216

# 적용
sudo sysctl -p
```

5. **파일 디스크립터 제한 해제**:

```bash
# /etc/security/limits.conf
* soft nofile 65535
* hard nofile 65535
```

### 보안 체크리스트

- HTTP API(`1985`) 포트를 외부에 노출하지 않기 (관리 목적만)
- `http_hooks`의 `on_publish`로 **스트림키 인증** 구현
- HTTPS(SSL) 적용 필수 (특히 WebRTC는 HTTPS 필수)
- 방화벽에서 필요한 포트만 개방
- RTMP 송출 인증 없이 운영하면 누구나 송출 가능 → 반드시 Callback 인증 적용

---

## 빠른 참조: 전체 흐름 요약

```
1. SRS 설치 (Docker 권장)
    docker run -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 8000:8000/udp ossrs/srs:5

2. 설정 (srs.conf)
    - HLS, HTTP-FLV, WebRTC 활성화
    - candidate 설정 (WebRTC용 공인IP)

3. 송출 (OBS / FFmpeg)
    rtmp://<서버IP>:1935/live/<스트림키>

4. 재생
    - HLS:      http://<서버IP>:8080/live/<스트림키>.m3u8
    - HTTP-FLV: http://<서버IP>:8080/live/<스트림키>.flv
    - WebRTC:   WHEP → http://<서버IP>:1985/rtc/v1/whep/?app=live&stream=<스트림키>

5. 프로덕션
    - Nginx 리버스 프록시 (SSL 종료)
    - Docker Compose로 배포
    - http_hooks로 인증/로깅
    - Edge 서버로 수평 확장
```

---

> 본 문서는 SRS 5.x 기준이며, 실무에서 사용하는 설정과 패턴 위주로 정리하였습니다.
