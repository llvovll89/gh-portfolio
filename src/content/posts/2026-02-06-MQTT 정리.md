---
title: MQTT 정리
date: 2026-02-06
summary: IoT·실시간 메시징의 핵심 프로토콜 MQTT - 개념부터 실전 활용까지
tags: [mqtt, iot, messaging, protocol, broker, pubsub]
---

# MQTT 정리 (IoT 개발자를 위한 실전 가이드)

**MQTT(Message Queuing Telemetry Transport)**는 IoT 환경에서 가장 많이 사용되는 **경량 메시징 프로토콜**입니다.

> 목표: MQTT의 **핵심 개념을 이해**하고 **바로 써먹을 수 있게** 정리

---

## 목차

1) MQTT란?
2) 핵심 개념 (Pub/Sub, Topic, QoS)
3) 브로커 (Broker)
4) 메시지 전송 흐름
5) QoS (Quality of Service)
6) Retained 메시지 & Last Will
7) 실전 예제 (Python, Node.js)
8) 브로커 설치 & 테스트
9) 보안 & 성능 최적화

---

## 1) MQTT란?

### 1.1 정의

**MQTT**는 1999년 IBM이 개발한 **경량 메시징 프로토콜**로, 제한된 네트워크 환경(저대역폭, 높은 지연)에서도 효율적으로 동작하도록 설계되었습니다.

현재 **OASIS 표준**이며, IoT·모바일·실시간 알림 시스템에서 널리 사용됩니다.

### 1.2 특징

- **경량**: HTTP보다 훨씬 작은 오버헤드
- **낮은 전력**: 배터리 기반 IoT 디바이스에 적합
- **Pub/Sub 모델**: 송신자와 수신자가 직접 연결되지 않음
- **QoS 지원**: 메시지 전송 신뢰성 보장
- **양방향 통신**: 클라이언트 ↔ 브로커

### 1.3 언제 사용하나?

| 상황 | 적합도 |
|---|---|
| **IoT 센서 데이터 수집** | ✅ 최적 |
| **스마트홈 제어** | ✅ 최적 |
| **실시간 알림 (푸시)** | ✅ 적합 |
| **채팅 앱** | ⚠️ 가능 (WebSocket도 고려) |
| **대용량 파일 전송** | ❌ 부적합 (HTTP/FTP 사용) |

---

## 2) 핵심 개념 (Pub/Sub, Topic, QoS)

### 2.1 Publish/Subscribe 모델

MQTT는 **발행-구독(Pub/Sub)** 패턴을 사용합니다.

```
Publisher (발행자)
    ↓
  Broker (중개자)
    ↓
Subscriber (구독자)
```

- **Publisher**: 메시지를 보내는 쪽
- **Subscriber**: 메시지를 받는 쪽
- **Broker**: 중간에서 메시지를 전달하는 서버

**장점**:
- 송신/수신자가 서로를 알 필요 없음
- 확장성 좋음 (브로커만 추가하면 됨)

### 2.2 Topic (토픽)

**Topic**은 메시지를 분류하는 "주소"입니다.

```
home/livingroom/temperature
home/bedroom/light
office/room1/humidity
```

**구조**:
- `/`로 계층 구조 표현
- 대소문자 구분
- 최대 65,535바이트

**와일드카드**:
- `+`: 한 레벨 와일드카드
  - `home/+/temperature` → `home/livingroom/temperature`, `home/bedroom/temperature` 매칭
- `#`: 다중 레벨 와일드카드 (끝에만 사용)
  - `home/#` → `home` 아래 모든 토픽 매칭

---

## 3) 브로커 (Broker)

### 3.1 역할

**브로커**는 MQTT의 핵심으로, 모든 메시지를 중개합니다.

주요 기능:
- 클라이언트 연결 관리
- Topic 기반 메시지 라우팅
- QoS 보장
- 세션 관리

### 3.2 주요 브로커

| 브로커 | 특징 | 용도 |
|---|---|---|
| **Mosquitto** | 오픈소스, 경량, 가장 많이 씀 | 개발/소규모 |
| **EMQX** | 고성능, 클러스터링 지원 | 대규모 상용 |
| **HiveMQ** | 상용, 엔터프라이즈급 | 상용 프로젝트 |
| **AWS IoT Core** | 클라우드 관리형 | AWS 생태계 |

### 3.3 Mosquitto 설치 (예시)

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install mosquitto mosquitto-clients

# macOS
brew install mosquitto

# 실행
mosquitto -v

# 기본 포트: 1883 (비암호화), 8883 (TLS)
```

---

## 4) 메시지 전송 흐름

### 4.1 기본 흐름

```
1. Publisher가 브로커에 연결
2. Publisher가 "home/temp" 토픽에 메시지 발행
3. Subscriber가 브로커에 연결
4. Subscriber가 "home/temp" 토픽 구독
5. 브로커가 해당 토픽 메시지를 Subscriber에게 전달
```

### 4.2 연결 과정

```
Client → CONNECT (username, password, clean session 등)
Broker → CONNACK (연결 성공/실패)
```

**Clean Session**:
- `true`: 연결 종료 시 세션 삭제 (일회성)
- `false`: 세션 유지 (재연결 시 미수신 메시지 받음)

---

## 5) QoS (Quality of Service)

### 5.1 QoS 레벨

MQTT는 **3가지 QoS 레벨**로 메시지 전송 신뢰성을 보장합니다.

| QoS | 이름 | 설명 | 사용 예시 |
|---|---|---|---|
| **0** | At most once | 최대 1번 전송 (보장 없음) | 온도 센서 (1초마다 갱신) |
| **1** | At least once | 최소 1번 전송 (중복 가능) | 알림 메시지 |
| **2** | Exactly once | 정확히 1번만 전송 | 결제·제어 명령 |

### 5.2 QoS 0 (Fire and Forget)

```
Publisher → PUBLISH → Broker → PUBLISH → Subscriber
```

- 가장 빠름
- 네트워크 장애 시 메시지 손실 가능
- **실시간 센서 데이터**에 적합

### 5.3 QoS 1 (Acknowledged Delivery)

```
Publisher → PUBLISH → Broker → PUBACK
Broker → PUBLISH → Subscriber → PUBACK
```

- 전송 확인 (ACK)
- 재전송 가능 → 메시지 중복 가능
- **중요하지만 중복 허용 가능한 데이터**

### 5.4 QoS 2 (Assured Delivery)

```
Publisher → PUBLISH → Broker → PUBREC → PUBREL → PUBCOMP
Broker → PUBLISH → Subscriber (동일 과정)
```

- 4단계 핸드셰이크
- 정확히 1번만 전송 보장
- **가장 느림**, 중요한 제어 명령에 사용

---

## 6) Retained 메시지 & Last Will

### 6.1 Retained Message

**Retained 메시지**는 브로커에 마지막 메시지를 저장하여, 새로운 구독자에게 즉시 전달합니다.

```python
# 발행 시 retained=True
client.publish("home/status", "online", retain=True)

# 새로운 구독자가 "home/status" 구독 시
# → 즉시 "online" 메시지 수신
```

**사용 예시**:
- 디바이스 상태 (온라인/오프라인)
- 최신 센서 값

### 6.2 Last Will and Testament (LWT)

클라이언트가 **비정상 종료** 시 브로커가 자동으로 전송할 메시지를 미리 설정합니다.

```python
client.will_set("home/device/status", "offline", qos=1, retain=True)
```

**동작**:
1. 클라이언트 연결 시 LWT 설정
2. 클라이언트가 예상치 못하게 끊김 (네트워크 장애 등)
3. 브로커가 자동으로 LWT 메시지 발행

**사용 예시**:
- 디바이스 이상 탐지
- 상태 모니터링

---

## 7) 실전 예제

### 7.1 Python (paho-mqtt)

**설치**:
```bash
pip install paho-mqtt
```

**Publisher (발행자)**:
```python
import paho.mqtt.client as mqtt
import time

# 브로커 연결
client = mqtt.Client()
client.connect("localhost", 1883, 60)

# 메시지 발행
while True:
    client.publish("home/temp", "23.5", qos=1)
    print("Published: 23.5")
    time.sleep(5)
```

**Subscriber (구독자)**:
```python
import paho.mqtt.client as mqtt

def on_connect(client, userdata, flags, rc):
    print(f"Connected: {rc}")
    client.subscribe("home/temp", qos=1)

def on_message(client, userdata, msg):
    print(f"Topic: {msg.topic}, Message: {msg.payload.decode()}")

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect("localhost", 1883, 60)
client.loop_forever()
```

### 7.2 Node.js (mqtt.js)

**설치**:
```bash
npm install mqtt
```

**Publisher**:
```javascript
const mqtt = require('mqtt');
const client = mqtt.connect('mqtt://localhost:1883');

client.on('connect', () => {
  setInterval(() => {
    client.publish('home/temp', '23.5', { qos: 1 });
    console.log('Published: 23.5');
  }, 5000);
});
```

**Subscriber**:
```javascript
const mqtt = require('mqtt');
const client = mqtt.connect('mqtt://localhost:1883');

client.on('connect', () => {
  client.subscribe('home/temp', { qos: 1 });
  console.log('Subscribed to home/temp');
});

client.on('message', (topic, message) => {
  console.log(`Topic: ${topic}, Message: ${message.toString()}`);
});
```

---

## 8) 브로커 설치 & 테스트

### 8.1 Mosquitto 설치 및 실행

```bash
# Ubuntu
sudo apt install mosquitto mosquitto-clients
sudo systemctl start mosquitto
sudo systemctl enable mosquitto

# 상태 확인
sudo systemctl status mosquitto
```

### 8.2 CLI로 테스트

**터미널 1 (Subscriber)**:
```bash
mosquitto_sub -h localhost -t test/topic -v
```

**터미널 2 (Publisher)**:
```bash
mosquitto_pub -h localhost -t test/topic -m "Hello MQTT!"
```

**와일드카드 테스트**:
```bash
# 모든 home 토픽 구독
mosquitto_sub -h localhost -t "home/#" -v

# 발행
mosquitto_pub -h localhost -t "home/livingroom/temp" -m "22.5"
mosquitto_pub -h localhost -t "home/bedroom/light" -m "on"
```

### 8.3 QoS 테스트

```bash
# QoS 0
mosquitto_pub -h localhost -t test/qos -m "QoS 0" -q 0

# QoS 1
mosquitto_pub -h localhost -t test/qos -m "QoS 1" -q 1

# QoS 2
mosquitto_pub -h localhost -t test/qos -m "QoS 2" -q 2
```

---

## 9) 보안 & 성능 최적화

### 9.1 보안

**기본 보안 설정**:

1. **TLS/SSL 암호화** (포트 8883)
```bash
# mosquitto.conf
listener 8883
cafile /etc/mosquitto/ca_certificates/ca.crt
certfile /etc/mosquitto/certs/server.crt
keyfile /etc/mosquitto/certs/server.key
```

2. **인증 (Username/Password)**
```bash
# 사용자 생성
mosquitto_passwd -c /etc/mosquitto/passwd username

# mosquitto.conf
allow_anonymous false
password_file /etc/mosquitto/passwd
```

3. **ACL (Access Control List)**
```bash
# acl.conf
user sensor
topic read home/temp

user controller
topic write home/light
```

### 9.2 성능 최적화

**Topic 설계**:
- 계층 구조 명확하게: `region/building/room/sensor`
- 너무 깊은 중첩 피하기 (3~5 레벨 권장)

**QoS 선택**:
- 센서 데이터 → QoS 0
- 일반 알림 → QoS 1
- 제어 명령 → QoS 2

**Keep Alive**:
```python
client.connect("localhost", 1883, keepalive=60)
```
- 적절한 값: 60~300초
- 너무 짧으면 네트워크 부하 증가

**Clean Session**:
- 일회성 연결 → `clean_session=True`
- 지속 연결 → `clean_session=False`

---

## 10) 실전 활용 패턴

### 10.1 스마트홈 예시

**Topic 구조**:
```
home/
  livingroom/
    temp
    humidity
    light/status
    light/control
  bedroom/
    temp
    light/status
    light/control
```

**시나리오**:
1. 온도 센서 → `home/livingroom/temp` (QoS 0, retained)
2. 조명 상태 → `home/livingroom/light/status` (QoS 1, retained)
3. 조명 제어 → `home/livingroom/light/control` (QoS 2)

### 10.2 원격 모니터링

```python
# 센서 (Publisher)
client.publish("factory/machine1/status", "running", qos=1, retain=True)
client.will_set("factory/machine1/status", "offline", qos=1, retain=True)

# 모니터링 시스템 (Subscriber)
client.subscribe("factory/#", qos=1)
```

---

## 정리

| 항목 | 권장 사항 |
|---|---|
| **QoS** | 센서=0, 알림=1, 제어=2 |
| **Retained** | 상태 정보에만 사용 |
| **Topic** | 계층 구조 명확히 |
| **보안** | TLS + 인증 필수 (운영 환경) |
| **Keep Alive** | 60~300초 |

**MQTT vs HTTP**:
- **MQTT**: IoT, 실시간, 저전력, 양방향
- **HTTP**: 웹 API, 요청/응답, 단방향

> MQTT는 **가볍고 빠르지만**, 올바른 QoS와 Topic 설계가 핵심입니다.
> 실전에서는 **브로커 이중화**와 **모니터링**도 필수!
