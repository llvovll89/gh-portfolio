---
title: "네트워크 정리"
date: 2026-02-25
summary: OSI 모델부터 TCP/IP, HTTP, DNS, 랜선 작업, Wi-Fi, 실무 명령어까지 네트워크 핵심 개념 정리
tags: [network, tcp, http, dns, socket, osi, wifi, lan, 네트워크]
---

# 네트워크 정리 (2026-02-25)

이 문서는 네트워크의 핵심 개념을 **OSI 모델 → TCP/IP → 주요 프로토콜 → 소켓 → 보안 → 실무(랜선/장비/Wi-Fi/명령어)** 흐름으로 정리합니다.

> 목표: 네트워크 동작 원리를 이해하고 실무와 면접에서 막히지 않기

---

## 목차

1. OSI 7계층 모델
2. TCP/IP 4계층 모델
3. IP 주소 & 서브넷
4. TCP vs UDP
5. HTTP / HTTPS
6. DNS (Domain Name System)
7. 소켓 프로그래밍
8. REST vs WebSocket
9. 네트워크 보안 기초
10. 자주 나오는 면접 질문
11. LAN 케이블 (랜선) 실무
12. 네트워크 장비 이해
13. Wi-Fi 실무
14. DHCP & 포트 포워딩
15. 실무 네트워크 명령어

---

## 1) OSI 7계층 모델

### 1.1 개념

**OSI(Open Systems Interconnection)** 모델은 네트워크 통신을 7개의 계층으로 나눈 표준 참조 모델입니다. 각 계층은 독립적인 역할을 가지며, 하위 계층에 서비스를 제공합니다.

```
7계층: 응용 (Application)   ← HTTP, FTP, DNS, SMTP
6계층: 표현 (Presentation)  ← SSL/TLS, 암호화, 인코딩
5계층: 세션 (Session)       ← 세션 수립/유지/종료
4계층: 전송 (Transport)     ← TCP, UDP
3계층: 네트워크 (Network)   ← IP, ICMP, 라우터
2계층: 데이터링크 (Data Link)← MAC, 이더넷, 스위치
1계층: 물리 (Physical)      ← 케이블, 허브, 전기신호
```

### 1.2 각 계층 요약

| 계층 | 이름 | 주요 장비/프로토콜 | 전송 단위 |
|---|---|---|---|
| 7 | 응용 | HTTP, FTP, SMTP | 메시지 |
| 6 | 표현 | SSL, JPEG, ASCII | 메시지 |
| 5 | 세션 | RPC, NetBIOS | 메시지 |
| 4 | 전송 | TCP, UDP | 세그먼트 |
| 3 | 네트워크 | IP, ICMP | 패킷 |
| 2 | 데이터링크 | 이더넷, MAC | 프레임 |
| 1 | 물리 | 케이블, 허브 | 비트 |

### 1.3 캡슐화 (Encapsulation)

데이터는 송신 측에서 상위 → 하위 계층으로 내려가며 헤더가 붙고(캡슐화), 수신 측에서는 하위 → 상위 계층으로 올라가며 헤더가 제거됩니다(역캡슐화).

```
[데이터] → [TCP헤더 + 데이터] → [IP헤더 + TCP헤더 + 데이터] → [이더넷 프레임]
```

> **암기 팁**: "아파서(7) 피(6)나서(5) 토(4)하고 난(3) 뒤(2) 피(1)" 또는 "Please Do Not Throw Sausage Pizza Away"

---

## 2) TCP/IP 4계층 모델

실무에서는 OSI 7계층보다 TCP/IP 4계층이 더 많이 사용됩니다.

```
4계층: 응용 (Application)   ← HTTP, DNS, FTP, SMTP
3계층: 전송 (Transport)     ← TCP, UDP
2계층: 인터넷 (Internet)    ← IP, ICMP, ARP
1계층: 네트워크 액세스      ← 이더넷, Wi-Fi, MAC
```

### OSI vs TCP/IP 비교

| OSI | TCP/IP | 주요 프로토콜 |
|---|---|---|
| 응용/표현/세션 (7,6,5) | 응용 | HTTP, DNS, FTP |
| 전송 (4) | 전송 | TCP, UDP |
| 네트워크 (3) | 인터넷 | IP, ICMP |
| 데이터링크/물리 (2,1) | 네트워크 액세스 | 이더넷, Wi-Fi |

---

## 3) IP 주소 & 서브넷

### 3.1 IPv4

- **형식**: 32비트, 점으로 구분된 4개의 옥텟 (예: `192.168.1.100`)
- **범위**: 0.0.0.0 ~ 255.255.255.255 (약 43억 개)

**클래스 분류:**

| 클래스 | 범위 | 사용 |
|---|---|---|
| A | 0.0.0.0 ~ 127.255.255.255 | 대규모 네트워크 |
| B | 128.0.0.0 ~ 191.255.255.255 | 중규모 네트워크 |
| C | 192.0.0.0 ~ 223.255.255.255 | 소규모 네트워크 |

**사설(Private) IP 대역:**

```
10.0.0.0/8
172.16.0.0/12
192.168.0.0/16
```

### 3.2 서브넷 마스크

서브넷 마스크는 IP 주소에서 **네트워크 부분**과 **호스트 부분**을 구분합니다.

```
IP 주소:    192.168.1.100  = 11000000.10101000.00000001.01100100
서브넷마스크: 255.255.255.0  = 11111111.11111111.11111111.00000000
              (= /24)

네트워크 주소: 192.168.1.0
브로드캐스트:  192.168.1.255
사용 가능 호스트: 192.168.1.1 ~ 192.168.1.254 (254개)
```

### 3.3 CIDR 표기

CIDR(Classless Inter-Domain Routing)은 `/숫자` 형식으로 서브넷 마스크를 표현합니다.

```
192.168.0.0/24 → 서브넷 마스크 255.255.255.0, 호스트 254개
192.168.0.0/16 → 서브넷 마스크 255.255.0.0,   호스트 65534개
```

### 3.4 IPv6

- **형식**: 128비트, 콜론으로 구분된 16진수 8개
- **예시**: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`
- **특징**: 약 3.4 × 10³⁸개의 주소, NAT 없이 종단 간 직접 통신

---

## 4) TCP vs UDP

### 4.1 TCP (Transmission Control Protocol)

**연결 지향**의 신뢰성 있는 전송 프로토콜입니다.

**특징:**
- 3-way 핸드셰이크로 연결 수립
- 데이터 순서 보장
- 재전송(ARQ)으로 신뢰성 보장
- 흐름 제어 & 혼잡 제어
- 속도가 UDP보다 느림

**3-way 핸드셰이크:**

```
클라이언트            서버
    |--- SYN -------->|   (연결 요청)
    |<-- SYN + ACK ---|   (요청 수락)
    |--- ACK -------->|   (연결 완료)
```

**4-way 핸드셰이크 (연결 종료):**

```
클라이언트            서버
    |--- FIN -------->|
    |<-- ACK ---------|
    |<-- FIN ---------|
    |--- ACK -------->|
```

**사용 예시**: HTTP/HTTPS, FTP, 이메일, 파일 전송

### 4.2 UDP (User Datagram Protocol)

**비연결형** 프로토콜로 빠른 전송에 특화됩니다.

**특징:**
- 연결 수립 과정 없음 (단방향 전송)
- 순서/재전송 보장 없음
- 오버헤드 적어 속도 빠름
- 멀티캐스트, 브로드캐스트 지원

**사용 예시**: DNS, 스트리밍, 온라인 게임, VoIP, DHCP

### 4.3 TCP vs UDP 비교

| 항목 | TCP | UDP |
|---|---|---|
| 연결 방식 | 연결 지향 | 비연결형 |
| 신뢰성 | 높음 (재전송) | 낮음 |
| 순서 보장 | O | X |
| 속도 | 상대적으로 느림 | 빠름 |
| 헤더 크기 | 20~60 bytes | 8 bytes |
| 사용 | HTTP, 파일 전송 | 스트리밍, 게임 |

---

## 5) HTTP / HTTPS

### 5.1 HTTP (HyperText Transfer Protocol)

**무상태(Stateless)** 프로토콜로 클라이언트와 서버 간 요청/응답 방식으로 동작합니다.

**HTTP 메서드:**

| 메서드 | 용도 | 멱등성 | 안전성 |
|---|---|---|---|
| GET | 리소스 조회 | O | O |
| POST | 리소스 생성 | X | X |
| PUT | 리소스 전체 수정 | O | X |
| PATCH | 리소스 부분 수정 | X | X |
| DELETE | 리소스 삭제 | O | X |

**HTTP 상태 코드:**

```
1xx: 정보 응답 (100 Continue)
2xx: 성공      (200 OK, 201 Created, 204 No Content)
3xx: 리다이렉션 (301 Moved, 302 Found, 304 Not Modified)
4xx: 클라이언트 오류 (400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found)
5xx: 서버 오류 (500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable)
```

### 5.2 HTTP 버전 비교

| 버전 | 특징 |
|---|---|
| HTTP/1.0 | 요청마다 연결, 비효율 |
| HTTP/1.1 | Persistent Connection(Keep-Alive), 파이프라이닝 |
| HTTP/2 | 멀티플렉싱, 헤더 압축(HPACK), 서버 푸시, 바이너리 프레임 |
| HTTP/3 | UDP 기반 QUIC, 핸드셰이크 감소, HOL 블로킹 해결 |

**HTTP/1.1 문제점 (HOL Blocking):**
```
요청1 ----→ 응답1
요청2 ----------→ 응답2   (순서 때문에 대기)
요청3 ----------------→ 응답3
```

**HTTP/2 멀티플렉싱:**
```
요청1 →
요청2 →  (단일 커넥션으로 병렬 전송)
요청3 →
```

### 5.3 HTTPS

**HTTPS = HTTP + TLS(Transport Layer Security)**

TLS 핸드셰이크 과정:

```
1. Client Hello (지원 TLS 버전, 암호화 알고리즘 목록 전송)
2. Server Hello (선택된 알고리즘, 서버 인증서 전송)
3. 클라이언트: 인증서 검증 (CA 서명 확인)
4. 세션 키 교환 (비대칭 키로 대칭 키 공유)
5. 이후 데이터는 대칭 키로 암호화 전송
```

### 5.4 헤더 주요 항목

```http
GET /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
Authorization: Bearer eyJhbGc...
Cache-Control: no-cache
Accept-Encoding: gzip, deflate

← 응답 →
HTTP/1.1 200 OK
Content-Type: application/json
Set-Cookie: session=abc; HttpOnly; Secure; SameSite=Strict
```

---

## 6) DNS (Domain Name System)

### 6.1 개념

DNS는 **도메인 이름을 IP 주소로 변환**하는 분산 데이터베이스 시스템입니다.

```
사용자가 "google.com" 입력
           ↓
DNS 조회 → 142.250.207.46 반환
           ↓
해당 IP 서버에 HTTP 요청
```

### 6.2 DNS 조회 과정

```
1. 브라우저 캐시 확인
2. OS 캐시 확인 (/etc/hosts 포함)
3. Local DNS 서버 (ISP 제공) 조회
4. Root DNS 서버 → TLD 서버(.com, .net) → 권한 DNS 서버
5. 최종 IP 반환 및 캐시 저장
```

**재귀적 질의 vs 반복적 질의:**
- **재귀적**: Local DNS 서버가 대신 전체 조회 수행
- **반복적**: 각 단계에서 다음 서버 주소만 반환, 클라이언트가 직접 질의

### 6.3 DNS 레코드 종류

| 레코드 | 설명 | 예시 |
|---|---|---|
| A | 도메인 → IPv4 | example.com → 93.184.216.34 |
| AAAA | 도메인 → IPv6 | example.com → 2001:db8::1 |
| CNAME | 별칭 → 다른 도메인 | www → example.com |
| MX | 메일 서버 지정 | mail.example.com |
| NS | 권한 DNS 서버 | ns1.example.com |
| TXT | 텍스트 정보 | SPF, DKIM 등 |
| PTR | IP → 도메인 (역방향) | 93.184.216.34 → example.com |

### 6.4 TTL (Time To Live)

DNS 응답을 캐시에 유지하는 시간(초 단위). TTL이 낮으면 변경이 빨리 반영되지만 DNS 조회가 잦아집니다.

---

## 7) 소켓 프로그래밍

### 7.1 소켓이란

소켓은 **응용 프로그램과 네트워크 스택 사이의 인터페이스**로, IP 주소 + 포트 번호로 통신 엔드포인트를 식별합니다.

```
소켓 = IP 주소 + 포트 번호
예: 192.168.1.100:8080
```

### 7.2 잘 알려진 포트 (Well-Known Ports)

| 포트 | 프로토콜 |
|---|---|
| 20, 21 | FTP (데이터, 제어) |
| 22 | SSH |
| 25 | SMTP |
| 53 | DNS |
| 80 | HTTP |
| 443 | HTTPS |
| 3306 | MySQL |
| 5432 | PostgreSQL |
| 6379 | Redis |
| 27017 | MongoDB |

### 7.3 TCP 소켓 통신 흐름

```
[서버]                    [클라이언트]
socket()                  socket()
bind()                        ↓
listen()                  connect() ──→
accept() ←──────────────────────────
   ↕ (read/write)              ↕
close()                   close()
```

**Node.js TCP 서버 예시:**

```js
const net = require('net');

const server = net.createServer((socket) => {
  console.log('클라이언트 연결:', socket.remoteAddress);

  socket.on('data', (data) => {
    console.log('수신:', data.toString());
    socket.write('에코: ' + data);
  });

  socket.on('end', () => {
    console.log('클라이언트 연결 종료');
  });
});

server.listen(8080, () => {
  console.log('서버 실행 중: 포트 8080');
});
```

**Node.js TCP 클라이언트 예시:**

```js
const net = require('net');

const client = net.connect({ port: 8080, host: '127.0.0.1' }, () => {
  client.write('Hello, Server!');
});

client.on('data', (data) => {
  console.log('서버 응답:', data.toString());
  client.end();
});
```

### 7.4 논블로킹 I/O & 멀티플렉싱

**블로킹 모델**: 하나의 연결에 하나의 스레드가 필요 → 연결 수 증가 시 스레드 폭발

**논블로킹/이벤트 드리븐**: 하나의 스레드로 여러 연결을 이벤트 루프로 처리

```
이벤트 루프
    ↓
[소켓1 읽기 가능] → 처리
[소켓2 쓰기 가능] → 처리
[소켓3 연결 요청] → 처리
```

> Node.js, Nginx는 이벤트 드리븐 + 논블로킹 I/O로 높은 동시성을 처리합니다.

---

## 8) REST vs WebSocket

### 8.1 REST API

- **HTTP 기반** 요청/응답 패턴
- 무상태(Stateless)
- 클라이언트가 먼저 요청해야 응답 가능

```
클라이언트 → 요청 → 서버
클라이언트 ← 응답 ← 서버
(연결 종료)
```

**적합한 경우**: 일반 CRUD, 데이터 조회, API 설계

### 8.2 WebSocket

- **양방향(Full-Duplex) 실시간 통신**
- HTTP 업그레이드로 연결 수립 후 지속 연결 유지
- 서버에서 먼저 클라이언트에 데이터 전송 가능 (Server Push)

```
HTTP Upgrade 핸드셰이크:
GET /chat HTTP/1.1
Upgrade: websocket
Connection: Upgrade

↕ (지속 연결)
서버 → 클라이언트 (Push 가능)
클라이언트 → 서버
```

**Node.js WebSocket 예시 (ws 라이브러리):**

```js
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('클라이언트 연결');

  ws.on('message', (message) => {
    console.log('수신:', message.toString());
    // 연결된 모든 클라이언트에 브로드캐스트
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message.toString());
      }
    });
  });

  ws.on('close', () => console.log('연결 종료'));
});
```

### 8.3 REST vs WebSocket vs SSE 비교

| 항목 | REST | WebSocket | SSE |
|---|---|---|---|
| 통신 방향 | 단방향 (요청/응답) | 양방향 | 서버 → 클라이언트 |
| 연결 | 요청 시마다 | 지속 | 지속 |
| 프로토콜 | HTTP | ws/wss | HTTP |
| 사용 | CRUD API | 실시간 채팅, 게임 | 알림, 실시간 피드 |

---

## 9) 네트워크 보안 기초

### 9.1 주요 공격 유형

**DoS / DDoS (Denial of Service)**
- 서버에 과부하를 발생시켜 서비스 불능 상태로 만드는 공격
- 대응: 트래픽 필터링, CDN, Rate Limiting, 방화벽

**중간자 공격 (Man-in-the-Middle, MITM)**
- 통신 중간에서 데이터를 가로채거나 변조
- 대응: HTTPS(TLS), 인증서 핀닝(Certificate Pinning)

**DNS 스푸핑 (DNS Spoofing)**
- DNS 응답을 위조해 사용자를 악성 서버로 유도
- 대응: DNSSEC, DoH(DNS over HTTPS)

**포트 스캐닝 (Port Scanning)**
- 열린 포트를 탐지해 취약점 파악
- 대응: 방화벽으로 불필요한 포트 차단

### 9.2 방화벽 & NAT

**방화벽 (Firewall)**
- 패킷 필터링: IP, 포트, 프로토콜 기반으로 허용/차단
- 상태 기반(Stateful): 연결 상태를 추적해 응답 패킷만 허용

**NAT (Network Address Translation)**
- 사설 IP → 공인 IP로 변환
- 하나의 공인 IP로 여러 내부 장비가 인터넷 통신 가능
- 포트 포워딩으로 내부 서비스를 외부에 노출 가능

```
내부: 192.168.1.100:12345 → NAT → 공인IP:45678 → 인터넷
```

### 9.3 TLS/SSL 인증서

```
인증서 구조:
- 도메인명
- 발급 기관 (CA: Certificate Authority)
- 유효기간
- 공개키
- CA의 디지털 서명
```

**인증서 검증 흐름:**
1. 서버가 인증서 전송
2. 클라이언트가 CA의 공개키로 서명 검증
3. 도메인 일치 여부 확인
4. 유효기간 확인

### 9.4 주요 보안 설정 체크리스트

- [ ] HTTPS 강제 적용 (HSTS 헤더)
- [ ] 불필요한 포트 방화벽으로 차단
- [ ] CORS 정책 설정 (허용 도메인 명시)
- [ ] 쿠키에 HttpOnly, Secure, SameSite 설정
- [ ] Rate Limiting 적용 (Brute Force 방지)
- [ ] 최신 TLS 버전 사용 (TLS 1.2+ 권장)

---

## 10) 자주 나오는 면접 질문

### Q1. TCP와 UDP의 차이점은?

```text
TCP: 연결 지향, 신뢰성 보장 (재전송, 순서 보장), 흐름/혼잡 제어
     → HTTP, 파일 전송, 이메일에 사용

UDP: 비연결형, 신뢰성 없음, 빠른 전송
     → 스트리밍, 게임, DNS, VoIP에 사용
```

### Q2. HTTP와 HTTPS의 차이는?

```text
HTTP: 평문 전송 → 도청, 변조 위험
HTTPS: TLS 레이어 추가 → 암호화, 무결성, 서버 인증 보장
```

### Q3. OSI 7계층에서 4계층의 역할은?

```text
전송 계층(Transport Layer): 프로세스 간 통신 담당
- 포트 번호로 프로세스 식별
- TCP/UDP 프로토콜 동작
- 흐름 제어, 오류 제어 (TCP)
```

### Q4. 3-way 핸드셰이크를 설명하라

```text
1. SYN: 클라이언트가 서버에 연결 요청 (ISN 포함)
2. SYN-ACK: 서버가 요청 수락, 자신의 ISN 포함
3. ACK: 클라이언트가 수락 확인
→ 이후 데이터 전송 가능
```

### Q5. DNS 조회 과정을 설명하라

```text
1. 브라우저 캐시 → OS 캐시 → hosts 파일 확인
2. Local DNS(ISP) 서버에 쿼리
3. Root DNS → TLD DNS(.com) → 권한 DNS 순으로 재귀 질의
4. 최종 IP 주소 반환 및 TTL 동안 캐시
```

### Q6. REST API와 WebSocket의 차이는?

```text
REST: 단방향(요청/응답), 무상태, HTTP 기반
      → 일반 데이터 조회/수정에 적합

WebSocket: 양방향, 지속 연결
           → 실시간 채팅, 주식 시세, 게임에 적합
```

### Q7. CORS란 무엇인가?

```text
CORS(Cross-Origin Resource Sharing): 다른 출처(도메인/포트/프로토콜)의
리소스를 요청할 때 브라우저가 적용하는 보안 정책.

서버에서 Access-Control-Allow-Origin 헤더로 허용할 출처를 명시해야 함.
Preflight 요청(OPTIONS)으로 사전 확인 후 실제 요청 전송.
```

---

## 11) LAN 케이블 (랜선) 실무

### 11.1 케이블 종류 (카테고리)

유선 네트워크에서 가장 많이 쓰이는 **UTP 케이블**은 카테고리(Cat) 등급으로 구분됩니다.

| 규격 | 최대 속도 | 최대 대역폭 | 최대 거리 | 특징 |
|---|---|---|---|---|
| Cat5 | 100 Mbps | 100 MHz | 100m | 구형, 거의 사용 안 함 |
| Cat5e | 1 Gbps | 100 MHz | 100m | 현재도 가정/사무실 표준 |
| Cat6 | 10 Gbps | 250 MHz | 55m (10G 기준) | 내부 십자형 분리대 |
| Cat6a | 10 Gbps | 500 MHz | 100m | 더 두꺼운 케이블 |
| Cat7 | 10 Gbps | 600 MHz | 100m | STP, 커넥터 규격 비표준 |
| Cat8 | 40 Gbps | 2000 MHz | 30m | 데이터센터용 |

> **실무 선택 기준**: 가정/소규모 사무실 → Cat5e, 기업 신규 구축 → Cat6a 권장

### 11.2 UTP vs STP

| 구분 | 내용 |
|---|---|
| **UTP** (Unshielded Twisted Pair) | 차폐 없음, 저렴, 일반 환경에 적합 |
| **STP** (Shielded Twisted Pair) | 금속 차폐 있음, 전자기 간섭(EMI)에 강함, 공장/의료 환경에 사용 |
| **FTP** (Foiled Twisted Pair) | 전체 쌍을 알루미늄 포일로 차폐 |

### 11.3 T568A vs T568B 배선 규격

**RJ-45 커넥터(수정형 잭)** 에 8가닥 선을 꽂는 순서입니다.

```
핀 번호:  1    2    3    4    5    6    7    8
T568A:  녹흰  녹   주흰  파   파흰  주   갈흰  갈
T568B:  주흰  주   녹흰  파   파흰  녹   갈흰  갈
```

- **T568B**가 미국/한국 사무실 환경에서 가장 많이 사용됩니다.
- 양쪽 모두 같은 규격으로 만들면 **다이렉트 케이블** (일반 패치 케이블)
- 양쪽을 다르게 만들면 **크로스오버 케이블** (PC ↔ PC 직접 연결, 현재는 Auto-MDI/X로 거의 불필요)

### 11.4 크림핑 작업 순서

현장에서 랜선을 직접 만들 때의 순서입니다.

```
1. 케이블 피복 약 3cm 제거 (케이블 스트리퍼 사용)
2. 8가닥 선 꼬임 풀기
3. T568B 순서대로 선 정렬
   주흰 - 주 - 녹흰 - 파 - 파흰 - 녹 - 갈흰 - 갈
4. 선 끝 일직선으로 자르기 (약 1.5cm 남기기)
5. RJ-45 커넥터에 선 밀어 넣기
   → 8가닥이 커넥터 앞 끝까지 닿아야 함
   → 피복이 커넥터 걸림 홈 안으로 들어와야 함
6. 크림핑 툴로 압착
7. 반대쪽도 동일 작업
8. LAN 테스터기로 8핀 점등 확인
```

> **실수 방지 포인트**
> - 선 정렬 후 자를 때 너무 짧으면 핀에 안 닿고, 너무 길면 피복이 커넥터 밖으로 나옴
> - 선이 투명 커넥터 끝에서 보여야 올바르게 삽입된 것
> - 크림핑 전 순서 꼭 재확인 (한 번 눌리면 되돌리기 불가)

### 11.5 LAN 테스터기 사용법

```
1. 케이블 양쪽을 테스터기 Master / Remote 포트에 연결
2. 전원 켜면 1~8번 LED가 순서대로 점등
3. 정상: 1→1, 2→2, 3→3 ... 8→8 순서로 점등
4. 단선: 해당 번호 LED 미점등
5. 쇼트(합선): 동시에 두 LED 점등
6. 크로스오버: 점등 순서가 달라짐 (정상 범위)
```

---

## 12) 네트워크 장비 이해

### 12.1 허브 vs 스위치 vs 라우터

| 장비 | OSI 계층 | 역할 | 특징 |
|---|---|---|---|
| **허브 (Hub)** | 1계층 (물리) | 신호 증폭/분배 | 모든 포트에 브로드캐스트, 충돌 도메인 공유, 현재 거의 미사용 |
| **스위치 (Switch)** | 2계층 (데이터링크) | MAC 주소 기반 프레임 전달 | 포트별 독립 통신, MAC 테이블로 대상 포트만 전송 |
| **라우터 (Router)** | 3계층 (네트워크) | IP 기반 패킷 경로 결정 | 네트워크 간 연결, NAT, DHCP 기능 포함 (가정용 공유기) |
| **AP (Access Point)** | 2계층 | 유선 ↔ 무선 브릿지 | Wi-Fi 신호 발생, 스위치/라우터에 연결 |

### 12.2 가정/사무실 네트워크 구성도

```
인터넷 (ISP)
    │
  ONU/모뎀 (광 → 이더넷 변환)
    │
  공유기 (라우터 + NAT + DHCP + Wi-Fi AP 통합)
  192.168.0.1  (게이트웨이)
    ├── PC1  192.168.0.10 (유선)
    ├── PC2  192.168.0.11 (유선)
    ├── 스위치 (포트 확장)
    │     ├── 서버  192.168.0.20
    │     └── NAS   192.168.0.21
    ├── 스마트폰  192.168.0.30 (Wi-Fi)
    └── TV       192.168.0.31 (Wi-Fi)
```

### 12.3 스위치의 MAC 테이블 동작

```
1. PC1 (MAC: AA) → PC2 (MAC: BB) 프레임 전송
2. 스위치: 포트1에서 MAC AA 학습 → 테이블에 저장
3. BB를 모르면 전체 포트에 플러딩(Flooding)
4. PC2가 응답 시 포트2에서 MAC BB 학습
5. 이후 AA↔BB 통신은 해당 포트끼리만 전달 (유니캐스트)
```

### 12.4 공유기(라우터) 설정 접속

```
브라우저 주소창에 기본 게이트웨이 입력
보통: 192.168.0.1 또는 192.168.1.1

확인 방법:
  Windows: ipconfig → 기본 게이트웨이
  Linux/Mac: ip route | grep default

기본 계정: admin / admin (반드시 변경 권장)
```

---

## 13) Wi-Fi 실무

### 13.1 주파수 대역 비교

| 구분 | 2.4 GHz | 5 GHz | 6 GHz (Wi-Fi 6E) |
|---|---|---|---|
| 속도 | 낮음 (최대 600 Mbps) | 높음 (최대 3.5 Gbps) | 매우 높음 |
| 거리/투과력 | 길고 장애물에 강함 | 짧고 장애물에 약함 | 짧음 |
| 혼잡도 | 높음 (구형 기기 많음) | 낮음 | 매우 낮음 (신규) |
| 채널 수 | 13개 (비겹침 3개: 1,6,11) | 25개+ (비겹침 많음) | 59개 |
| 적합한 상황 | 멀리 있는 기기, IoT | 가까운 기기, 고속 전송 | 최신 고성능 |

> **실무 팁**: 집이 넓거나 벽이 많으면 2.4 GHz, 같은 공간에서 빠른 속도가 필요하면 5 GHz를 선택하세요.

### 13.2 Wi-Fi 규격 (802.11)

| 규격 | 브랜드명 | 주파수 | 최대 속도 | 출시 |
|---|---|---|---|---|
| 802.11b | - | 2.4 GHz | 11 Mbps | 1999 |
| 802.11g | - | 2.4 GHz | 54 Mbps | 2003 |
| 802.11n | Wi-Fi 4 | 2.4/5 GHz | 600 Mbps | 2009 |
| 802.11ac | Wi-Fi 5 | 5 GHz | 3.5 Gbps | 2013 |
| 802.11ax | Wi-Fi 6/6E | 2.4/5/6 GHz | 9.6 Gbps | 2019 |
| 802.11be | Wi-Fi 7 | 2.4/5/6 GHz | 46 Gbps | 2024 |

### 13.3 채널 & 간섭

2.4 GHz는 채널이 겹쳐 간섭이 발생합니다. 비겹침 채널인 **1, 6, 11번** 사용을 권장합니다.

```
채널 1:  ████████
채널 6:       ████████
채널 11:           ████████
(서로 겹치지 않음)

채널 3:    ████████
채널 5:      ████████
(겹침 발생 → 간섭, 속도 저하)
```

> 공유기 관리 페이지 → 무선 설정 → 채널을 **자동**으로 두거나 인근 AP와 다른 채널 수동 설정

### 13.4 Wi-Fi 보안 규격

| 규격 | 상태 | 비고 |
|---|---|---|
| WEP | 취약 (사용 금지) | RC4 암호화, 쉽게 크랙됨 |
| WPA | 취약 (권장 안함) | TKIP 사용 |
| WPA2 | 현재 표준 | AES-CCMP 사용, 안전 |
| WPA3 | 최신 권장 | SAE 핸드셰이크, 더 강력 |

> 공유기 설정에서 보안 방식을 반드시 **WPA2** 또는 **WPA3**로 설정하세요.

---

## 14) DHCP & 포트 포워딩

### 14.1 DHCP (Dynamic Host Configuration Protocol)

네트워크에 연결될 때 **자동으로 IP 주소를 할당**받는 프로토콜입니다.

**DORA 과정:**

```
클라이언트                        DHCP 서버(보통 공유기)
    │                                    │
    │── DISCOVER (브로드캐스트) ─────────▶│  "IP 주소 있는 서버 있나요?"
    │                                    │
    │◀─ OFFER (IP 제안) ─────────────────│  "192.168.0.50 어때요?"
    │                                    │
    │── REQUEST (IP 요청) ───────────────▶│  "그 IP 주세요"
    │                                    │
    │◀─ ACK (확인/할당) ─────────────────│  "사용하세요 (임대 시간: 24시간)"
```

할당 정보에는 **IP 주소, 서브넷 마스크, 게이트웨이, DNS 서버** 가 포함됩니다.

### 14.2 고정 IP 설정 (IP 예약)

특정 기기에 항상 같은 IP를 주고 싶을 때 사용합니다.

**방법 1 - 공유기에서 MAC 주소 바인딩 (권장)**
```
공유기 관리 페이지 → DHCP → IP 예약(Address Reservation)
→ 장비의 MAC 주소 입력 → 원하는 IP 입력 → 저장
→ 이후 해당 기기는 항상 같은 IP를 할당받음
```

**방법 2 - 기기에서 직접 고정 IP 설정**
```
Windows:
  네트워크 연결 → 속성 → IPv4 → 수동 입력
  IP: 192.168.0.100
  서브넷: 255.255.255.0
  게이트웨이: 192.168.0.1
  DNS: 8.8.8.8 (Google DNS)

Linux:
  /etc/netplan/... 또는 nmcli 사용
```

> **주의**: 수동 설정 시 DHCP 범위 밖 IP를 사용하거나, 충돌 방지를 위해 공유기에서 해당 IP를 예약하세요.

### 14.3 포트 포워딩 (Port Forwarding)

외부 인터넷에서 내부 사설 IP의 특정 서비스로 접근할 때 사용합니다.

**동작 원리:**

```
외부 사용자
    │ 공인IP:8080 으로 접속
    ▼
[공유기 NAT]
    │ 포트 포워딩 규칙 적용
    │ 외부 8080 → 내부 192.168.0.20:3000
    ▼
내부 서버 192.168.0.20:3000
```

**설정 예시:**

```
공유기 관리 페이지 → NAT → 포트 포워딩

[규칙 추가]
서비스명: MyWebApp
외부 포트: 8080
내부 IP:   192.168.0.20
내부 포트: 3000
프로토콜: TCP
```

**실무 활용 예시:**

| 서비스 | 외부 포트 | 내부 포트 |
|---|---|---|
| 웹 서버 | 80 | 80 |
| HTTPS | 443 | 443 |
| SSH 원격 접속 | 2222 | 22 |
| Node.js 앱 | 8080 | 3000 |
| Minecraft 서버 | 25565 | 25565 |

> **보안 주의**: SSH(22번)를 외부에 직접 노출하지 말고 포트 변경 + 키 인증 사용 권장

### 14.4 공인 IP 확인 방법

```bash
# 터미널에서 확인
curl ifconfig.me
curl ipinfo.io/ip
```

---

## 15) 실무 네트워크 명령어

### 15.1 ping

네트워크 연결 상태와 응답 시간을 확인합니다.

```bash
# 기본 사용
ping google.com
ping 8.8.8.8

# Windows: 횟수 지정
ping -n 10 google.com

# Linux/Mac: 횟수 지정
ping -c 10 google.com

# 응답 예시
Reply from 142.250.207.46: bytes=32 time=15ms TTL=118
# time: 왕복 지연 시간 (낮을수록 좋음)
# TTL: 패킷이 거친 라우터 홉 수 추정 가능
```

**응답 없을 때 원인:**
- 대상 서버가 ICMP를 차단 (방화벽)
- 네트워크 단절
- DNS 문제 (IP 직접 입력 시 되는지 확인)

### 15.2 tracert / traceroute

패킷이 목적지까지 거치는 **경로(라우터)** 를 추적합니다.

```bash
# Windows
tracert google.com

# Linux/Mac
traceroute google.com

# 출력 예시
1    1 ms    1 ms    1 ms  192.168.0.1      ← 공유기
2   10 ms    9 ms   10 ms  121.160.x.x      ← ISP 라우터
3   12 ms   11 ms   13 ms  112.174.x.x
...
10  15 ms   14 ms   15 ms  142.250.207.46   ← 목적지

# * 표시: 해당 라우터가 ICMP 응답을 차단
```

### 15.3 ipconfig / ifconfig / ip

**네트워크 인터페이스 정보** 를 확인합니다.

```bash
# Windows
ipconfig                  # 기본 정보
ipconfig /all             # MAC 주소, DHCP 정보 포함
ipconfig /release         # DHCP IP 반납
ipconfig /renew           # DHCP IP 재할당
ipconfig /flushdns        # DNS 캐시 초기화

# Linux (구버전)
ifconfig

# Linux (최신)
ip addr show              # IP 주소 목록
ip route show             # 라우팅 테이블
ip neigh show             # ARP 테이블 (MAC↔IP)
```

### 15.4 netstat / ss

**열린 포트, 연결 상태** 를 확인합니다.

```bash
# Windows
netstat -an               # 모든 연결/포트 표시
netstat -ano              # PID 포함

# Linux/Mac
netstat -tuln             # TCP/UDP 수신 대기 포트
ss -tuln                  # netstat 대체 (더 빠름)

# 출력 예시
Proto  Local Address       State       PID
TCP    0.0.0.0:80          LISTENING   1234   ← 80포트 열림
TCP    192.168.0.10:52341  ESTABLISHED        ← HTTPS 연결 중
```

> **실무 활용**: 서버에서 특정 포트가 열려있는지 확인, 예상치 못한 외부 연결 탐지

### 15.5 nslookup / dig

**DNS 조회** 를 수동으로 실행합니다.

```bash
# nslookup (Windows/Linux/Mac)
nslookup google.com
nslookup google.com 8.8.8.8    # 특정 DNS 서버로 조회

# dig (Linux/Mac)
dig google.com
dig google.com MX              # MX 레코드 (메일 서버)
dig @8.8.8.8 google.com       # Google DNS로 조회
dig +short google.com          # IP만 출력
```

### 15.6 curl

**HTTP 요청** 을 명령줄에서 실행합니다.

```bash
# GET 요청
curl https://api.example.com/users

# 헤더 포함 요청
curl -H "Authorization: Bearer token123" https://api.example.com/me

# POST 요청 (JSON)
curl -X POST https://api.example.com/users \
     -H "Content-Type: application/json" \
     -d '{"name": "홍길동", "email": "hong@test.com"}'

# 응답 헤더만 확인
curl -I https://google.com

# 파일 다운로드
curl -O https://example.com/file.zip

# 공인 IP 확인
curl ifconfig.me
```

### 15.7 네트워크 트러블슈팅 순서

인터넷이 안 될 때 단계적으로 원인을 좁히는 방법입니다.

```
1단계: 물리 연결 확인
  → 케이블 연결 여부, 랜선 LED 점등, Wi-Fi 연결 상태

2단계: 로컬 게이트웨이 ping
  → ping 192.168.0.1 (공유기 응답 확인)
  → 실패 시: 케이블/드라이버 문제

3단계: 외부 IP로 ping
  → ping 8.8.8.8 (구글 DNS)
  → 실패 시: 공유기 ~ ISP 구간 문제

4단계: 도메인으로 ping
  → ping google.com
  → 실패 시: DNS 문제 (ipconfig /flushdns 후 재시도)

5단계: 특정 포트 연결 확인
  → curl -I https://google.com
  → 실패 시: 방화벽/프록시 문제
```

---

## 정리

| 개념 | 핵심 요약 |
|---|---|
| OSI 7계층 | 네트워크 통신 표준 참조 모델, 계층별 독립적 역할 |
| TCP/IP | 실무에서 사용되는 4계층 모델 |
| IPv4/IPv6 | IPv4 32비트(43억), IPv6 128비트(무한) |
| TCP | 신뢰성 O, 느림 / UDP: 신뢰성 X, 빠름 |
| HTTP | 무상태 요청/응답 프로토콜 |
| HTTPS | HTTP + TLS, 암호화/인증 제공 |
| DNS | 도메인 → IP 변환, 분산 계층 구조 |
| WebSocket | 양방향 실시간 통신 |
| 방화벽/NAT | 네트워크 보호 및 IP 변환 |
| 랜선 (UTP) | Cat5e/Cat6, T568B 배선, 크림핑 작업 |
| 네트워크 장비 | 허브(1계층) → 스위치(2계층) → 라우터(3계층) |
| Wi-Fi | 2.4GHz(넓은 범위) vs 5GHz(빠른 속도), WPA2/3 사용 |
| DHCP | IP 자동 할당 (DORA), 고정 IP는 MAC 바인딩 권장 |
| 포트 포워딩 | 공유기에서 외부 포트 → 내부 서버 IP:포트 연결 |
| 실무 명령어 | ping, tracert, ipconfig, netstat, nslookup, curl |

> 네트워크는 **계층 구조**와 **캡슐화** 개념을 먼저 잡고, 각 프로토콜의 역할과 특징을 연결하면 전체 그림이 보입니다.
> 이론 공부 후 직접 랜선을 만들고, 공유기를 설정해보는 것이 가장 빠른 이해 방법입니다.

---
작성일: 2026-02-25
