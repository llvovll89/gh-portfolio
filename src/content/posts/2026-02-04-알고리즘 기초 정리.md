---
title: 자바스크립트 알고리즘 기초 정리
date: 2026-02-04
summary: 코딩테스트 대비용 알고리즘/자료구조 핵심 요약 + JavaScript 예시 모음
tags: [javascript, algorithm, codingtest, datastructure]
---

# 자바스크립트 알고리즘 기초 정리 (코테용)

이 글은 **코딩테스트에서 자주 쓰는 개념/패턴**을 JavaScript 기준으로 정리한 노트입니다.   
"정의 → 언제 쓰는지 → 짧은 예시" 순서로 구성.

---

## 목차

**1)** 코테용 입력 템플릿(Node.js)   
**2)** 시간복잡도 감각   
**3)** JS 자료구조 치트시트   
**4)** 필수 패턴   
**5)** 그래프 탐색(BFS/DFS)   
**6)** DP(동적 계획법) 기초   
**7)** 그리디 기초   
**8)** 실수 방지 체크리스트   

---

## 1) 코테용 입력 템플릿(Node.js)

대부분 플랫폼(BOJ 등)에서 Node.js는 아래처럼 시작하면 편합니다.

```js
// BOJ / Node.js 입력 템플릿
const fs = require("fs");
const input = fs.readFileSync(0, "utf8").trim();

// 입력이 비어있는 경우도 대비
const tokens = input ? input.split(/\s+/) : [];
let idx = 0;
const next = () => tokens[idx++];

// 예시: 정수 하나 읽기
const n = Number(next() ?? 0);
// console.log(n);
```

자주 쓰는 파싱 예시:

```js
// 1) 한 줄에 N개 정수
// const arr = Array.from({ length: n }, () => Number(next()));

// 2) 2차원 격자(H x W)
// const grid = Array.from({ length: H }, () => next().split(""));

// 3) 큰 정수 (주의: BigInt)
// const x = BigInt(next());
// console.log(String(x));
```

---

## 2) 시간복잡도 감각

### Big-O 한 줄 요약

- `O(1)`: 한 번에 끝남
- `O(log N)`: 반으로 줄여가며 탐색(이진 탐색)
- `O(N)`: 한 번 훑기
- `O(N log N)`: 정렬/힙
- `O(N^2)`: 이중 루프(보통 N이 작을 때만)

### JS에서 체감되는 포인트

- `arr.sort()`는 기본적으로 문자열 정렬이므로 **숫자 정렬은 비교함수 필수**
	- `arr.sort((a, b) => a - b)`
- 큐를 `shift()`로 구현하면 내부적으로 당겨서 **O(N)** 이 될 수 있어요 → 포인터 큐 권장

---

## 3) JS 자료구조 치트시트

### 3.1 배열(Array)

```js
const arr = [3, 1, 2];

arr.push(4); // 뒤에 추가
arr.pop(); // 뒤 제거

// 숫자 정렬(필수)
arr.sort((a, b) => a - b);

// 2차원 배열 만들기
const H = 3, W = 4;
const grid = Array.from({ length: H }, () => Array(W).fill(0));
```

### 3.2 Map / Object (해시)

**빈도수/존재 확인**에 최적.

```js
// Map 빈도 카운트
const words = ["a", "b", "a"];
const freq = new Map();
for (const w of words) freq.set(w, (freq.get(w) ?? 0) + 1);
// freq.get("a") === 2

// Object로도 가능
const cnt = Object.create(null);
for (const w of words) cnt[w] = (cnt[w] ?? 0) + 1;
```

### 3.3 Set (중복 제거)

```js
const unique = [...new Set([1, 1, 2, 3])]; // [1,2,3]
```

### 3.4 스택(Stack): LIFO

```js
const st = [];
st.push(1);
st.push(2);
const top = st.pop(); // 2
```

괄호 검사 예시:

```js
function isValidParen(s) {
	const st = [];
	const pair = { ")": "(", "]": "[", "}": "{" };
	for (const ch of s) {
		if (ch === "(" || ch === "[" || ch === "{") st.push(ch);
		else {
			if (st.pop() !== pair[ch]) return false;
		}
	}
	return st.length === 0;
}
```

### 3.5 큐(Queue): FIFO (포인터 큐)

```js
const q = [];
let head = 0;

q.push(10);
q.push(20);

const x = q[head++]; // 10
const y = q[head++]; // 20
```

### 3.6 우선순위 큐(최소 힙)

다익스트라/최소값 반복 추출 등에 사용.

```js
class MinHeap {
	constructor() {
		this.h = [];
	}
	size() {
		return this.h.length;
	}
	peek() {
		return this.h[0];
	}
	push(x) {
		const h = this.h;
		h.push(x);
		let i = h.length - 1;
		while (i > 0) {
			const p = (i - 1) >> 1;
			if (h[p] <= h[i]) break;
			[h[p], h[i]] = [h[i], h[p]];
			i = p;
		}
	}
	pop() {
		const h = this.h;
		if (h.length === 0) return undefined;
		const root = h[0];
		const last = h.pop();
		if (h.length > 0) {
			h[0] = last;
			let i = 0;
			while (true) {
				let l = i * 2 + 1;
				let r = l + 1;
				let m = i;
				if (l < h.length && h[l] < h[m]) m = l;
				if (r < h.length && h[r] < h[m]) m = r;
				if (m === i) break;
				[h[i], h[m]] = [h[m], h[i]];
				i = m;
			}
		}
		return root;
	}
}
```

---

## 4) 필수 패턴

### 4.1 누적합(Prefix Sum)

구간합을 빠르게 만들 때.

```js
function buildPrefixSum(a) {
	const ps = Array(a.length + 1).fill(0);
	for (let i = 0; i < a.length; i++) ps[i + 1] = ps[i] + a[i];
	return ps;
}

// [l, r) 구간합
function rangeSum(ps, l, r) {
	return ps[r] - ps[l];
}

// 예시
const a = [2, 1, 3, 4];
const ps = buildPrefixSum(a);
// 1~3 인덱스(1,2) 합 => a[1] + a[2] = 1+3 = 4
// rangeSum(ps, 1, 3) === 4
```

### 4.2 투 포인터(Two Pointers)

정렬된 배열에서 합/조건 만족 쌍 찾기.

```js
function hasPairSum(sortedArr, target) {
	let l = 0;
	let r = sortedArr.length - 1;
	while (l < r) {
		const sum = sortedArr[l] + sortedArr[r];
		if (sum === target) return true;
		if (sum < target) l++;
		else r--;
	}
	return false;
}
```

### 4.3 슬라이딩 윈도우(Sliding Window)

연속 구간(부분배열) 문제에서 자주 등장.

```js
// 길이 k인 연속 부분합의 최대값
function maxSumFixedWindow(arr, k) {
	if (k > arr.length) return null;
	let sum = 0;
	for (let i = 0; i < k; i++) sum += arr[i];
	let best = sum;
	for (let i = k; i < arr.length; i++) {
		sum += arr[i] - arr[i - k];
		if (sum > best) best = sum;
	}
	return best;
}
```

### 4.4 이진 탐색(Binary Search)

정렬된 배열 탐색 + 파라메트릭 서치(정답이 단조성을 가질 때).

```js
// lowerBound: 처음으로 arr[i] >= target 인 인덱스
function lowerBound(arr, target) {
	let lo = 0;
	let hi = arr.length; // [lo, hi)
	while (lo < hi) {
		const mid = (lo + hi) >> 1;
		if (arr[mid] >= target) hi = mid;
		else lo = mid + 1;
	}
	return lo;
}

// 존재 여부
function exists(arr, x) {
	const i = lowerBound(arr, x);
	return i < arr.length && arr[i] === x;
}
```

---

## 5) 그래프 탐색(BFS/DFS)

### 5.1 인접 리스트 그래프 만들기

```js
const N = 5; // 정점 수
const g = Array.from({ length: N + 1 }, () => []);

function addEdge(u, v) {
	g[u].push(v);
	g[v].push(u);
}
```

### 5.2 BFS (최단거리: 간선 가중치가 1일 때)

```js
function bfs(start, g) {
	const dist = Array(g.length).fill(-1);
	const q = [];
	let head = 0;

	dist[start] = 0;
	q.push(start);

	while (head < q.length) {
		const u = q[head++];
		for (const v of g[u]) {
			if (dist[v] !== -1) continue;
			dist[v] = dist[u] + 1;
			q.push(v);
		}
	}
	return dist;
}
```

### 5.3 DFS (연결 요소, 사이클, 백트래킹)

재귀 DFS는 깊이가 크면 스택오버플로우가 날 수 있어 반복형도 자주 씁니다.

```js
function dfsIter(start, g) {
	const vis = Array(g.length).fill(false);
	const st = [start];
	vis[start] = true;

	while (st.length) {
		const u = st.pop();
		for (const v of g[u]) {
			if (vis[v]) continue;
			vis[v] = true;
			st.push(v);
		}
	}
	return vis;
}
```

---

## 6) DP(동적 계획법) 기초

### 언제 DP인가?

- 큰 문제를 작은 문제로 나눌 수 있음(점화식)
- 작은 문제가 반복됨

피보나치(가장 기본 형태):

```js
function fib(n) {
	if (n <= 1) return n;
	let a = 0;
	let b = 1;
	for (let i = 2; i <= n; i++) {
		const c = a + b;
		a = b;
		b = c;
	}
	return b;
}
```

---

## 7) 그리디 기초

그리디는 "매 순간 최선"이 "전체 최선"으로 이어지는 근거가 있어야 합니다.
정렬과 같이 나오는 경우가 많아요.

회의실 배정(개념 예시):

- 끝나는 시간이 빠른 순으로 정렬
- 겹치지 않으면 선택

```js
function maxMeetings(intervals) {
	intervals.sort((a, b) => a.end - b.end);
	let count = 0;
	let lastEnd = -Infinity;
	for (const it of intervals) {
		if (it.start >= lastEnd) {
			count++;
			lastEnd = it.end;
		}
	}
	return count;
}
```

---

## 8) 실수 방지 체크리스트

- [ ] 숫자 정렬에 `sort((a,b)=>a-b)`를 넣었는가?
- [ ] 큐를 `shift()`로 구현해 느려지지 않는가?
- [ ] 0-index/1-index를 섞지 않았는가?
- [ ] 입력이 비어도 터지지 않는가? (`trim()` 결과 `""`)
- [ ] 시간복잡도가 제한 내인지 대략 감이 오는가?

---

