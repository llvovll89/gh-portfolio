---
title: TypeScript 정리
date: 2026-01-26
summary: TypeScript 정리 글 입니다.
tags: [ts, frontend, TypeScript]
---

# TypeScript 필수 지식 정리(실무 기준)

이 글은 **TS를 써서 “런타임 버그를 줄이고”, “리팩터링을 쉽게”** 하기 위해 꼭 알아야 할 핵심만 압축 정리한 노트입니다.

---

## 1) TS는 “타입 검사” 도구다 (런타임이 아님)

- TypeScript 타입은 **컴파일(트랜스파일) 단계**에서만 의미가 있고,
- 실행 시점(JS 런타임)에는 **타입 정보가 사라짐**.

즉, TS는 “안전한 코드 작성”을 돕지만, **실제 데이터 검증(런타임 검증)**은 별도 처리 필요(예: Zod, Yup, 직접 검증).

---

## 2) 기본 타입 & 추론

```ts
let name = "kim"; // string으로 추론
let age = 27; // number로 추론
let ok = true; // boolean
let ids = [1, 2, 3]; // number[]
```

- 가능한 한 **명시보다 추론을 활용**하되,
- 공개 API(함수 인자/리턴, 컴포넌트 props, 모듈 export)는 **명시를 선호**.

---

## 3) 객체 타입: `type` vs `interface`

둘 다 많이 쓰며 큰 차이는 “확장/병합” 성격입니다.

- `interface`: 선언 병합 가능(같은 이름을 합침), OOP 스타일에 친화적
- `type`: 유니온/교차 등 표현이 강력, 더 유연한 조합 가능

```ts
type User = {id: string; name: string};
interface IUser {
    id: string;
    name: string;
}

type Admin = User & {role: "admin"};
interface IAdmin extends IUser {
    role: "admin";
}
```

실무 팁:

- **도메인 모델/DTO**는 `type` 선호(유니온 조합이 잦음)
- **라이브러리/클래스 계약**은 `interface`도 자주 사용

---

## 4) 유니온/인터섹션(교차) 타입

### 유니온(OR): `A | B`

```ts
type Id = string | number;

function printId(id: Id) {
    if (typeof id === "string") {
        console.log(id.toUpperCase());
    } else {
        console.log(id.toFixed(0));
    }
}
```

### 교차(AND): `A & B`

```ts
type WithTimestamps = {createdAt: string; updatedAt: string};
type Post = {title: string; body: string} & WithTimestamps;
```

---

## 5) 타입 좁히기(Narrowing) — TS 실력의 핵심

### 5.1 `typeof`, `in`, `instanceof`

```ts
function f(x: string | {toString(): string}) {
    if (typeof x === "string") return x.length;
    return x.toString();
}

type A = {a: number};
type B = {b: number};
function g(x: A | B) {
    if ("a" in x) return x.a;
    return x.b;
}
```

### 5.2 Discriminated Union(태그 유니온) — 강력 추천 패턴

```ts
type Result = {ok: true; data: string} | {ok: false; error: string};

function handle(r: Result) {
    if (r.ok) return r.data;
    return r.error;
}
```

---

## 6) 함수 타입: 인자/리턴/옵셔널/기본값

```ts
function sum(a: number, b: number): number {
    return a + b;
}

type Options = {limit?: number};
function fetchList(opts: Options = {}) {
    const limit = opts.limit ?? 20;
    return limit;
}
```

- `?:` 는 “있을 수도, 없을 수도”
- `??` 는 null/undefined에만 기본값 적용

---

## 7) `any` 금지, `unknown` 활용

- `any`: 타입 체크를 포기(확산되면 프로젝트가 무너짐)
- `unknown`: “모르지만 안전하게 다루겠다” (좁히기 강제)

```ts
function parseJson(raw: string): unknown {
    return JSON.parse(raw);
}

const v = parseJson("{}");
if (typeof v === "object" && v !== null && "id" in v) {
    // 여기서부터 안전하게 좁혀서 사용
}
```

---

## 8) Generics(제네릭) — 재사용 가능한 타입

```ts
function identity<T>(value: T): T {
    return value;
}

type ApiResponse<T> = {
    data: T;
    status: number;
};

const r: ApiResponse<{id: string}> = {data: {id: "1"}, status: 200};
```

제네릭 제약(Constraints):

```ts
function len<T extends {length: number}>(x: T) {
    return x.length;
}
```

---

## 9) keyof / typeof / Indexed Access — 타입을 “코드에서 뽑아 쓰기”

```ts
const theme = {mode: "dark", fontSize: 14};
type Theme = typeof theme; // { mode: string; fontSize: number }
type ThemeKey = keyof Theme; // "mode" | "fontSize"
type FontSize = Theme["fontSize"]; // number
```

실무 팁:

- **상수 객체를 타입의 근거로** 쓰면 유지보수가 좋아짐.

---

## 10) 유틸리티 타입(자주 씀)

- `Partial<T>`: 전부 optional
- `Required<T>`: 전부 required
- `Pick<T, K>`: 필요한 키만
- `Omit<T, K>`: 특정 키 제거
- `Record<K, V>`: 키-값 맵
- `ReturnType<F>`, `Parameters<F>`: 함수 시그니처에서 추출

```ts
type User = {id: string; name: string; email: string};

type UserPreview = Pick<User, "id" | "name">;
type UserForm = Omit<User, "id">;

type ById = Record<string, User>;
```

---

## 11) 만족(타입) vs 강제(캐스팅)

### 11.1 `as` 캐스팅(조심해서)

```ts
const el = document.querySelector("#app") as HTMLDivElement;
// 런타임에서 진짜 div가 아닐 수도 있음(주의)
```

### 11.2 `satisfies` (가능하면 이걸 선호)

값의 형태를 “검사”하면서도 리터럴 타입을 유지하기 좋음.

```ts
const routes = {
    home: "/",
    blog: "/blog",
} satisfies Record<string, `/${string}`>;
```

---

## 12) tsconfig에서 실무 추천 옵션(핵심)

보통 아래를 켜는 편이 안전합니다.

- `"strict": true`
- `"noUncheckedIndexedAccess": true` (선택)
- `"exactOptionalPropertyTypes": true` (선택, 팀 합의 필요)

Vite/React 환경이면 기본 템플릿이 많은 걸 이미 셋업해줍니다.

---

## 13) 자주 나는 실수/팁

- `!`(non-null assertion) 남발 금지:  
  “지금은 null 아니야”를 코드로 *강제*하는데, 미래에 깨짐.
- API 응답은 **런타임 검증**(스키마 검증)과 같이 가는 게 안정적.
- 타입은 “정확성”보다 **유지보수성**이 더 중요할 때가 많음  
  (너무 복잡한 타입 퍼즐은 팀 생산성을 떨어뜨림).
